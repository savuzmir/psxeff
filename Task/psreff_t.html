
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
    <head>
        <title>'psreff3' [PsychoPy]</title>
        <meta content="">
        <link href="js/vendors//jquery-ui-1.11.4.base/jquery-ui.min.css" rel="stylesheet">

        <style>
            /* project and resource dialogs */
            label, input { display:block; padding-bottom: .5em; }
            input.text { margin-bottom:1em; width:95%; padding: .5em; }
            fieldset { padding:0; border:0; margin-top:25px; }

            /* don't display close button in the top right corner of the box */
            .no-close .ui-dialog-titlebar-close { display: none; }
        </style>
    </head>

    <body>

        <!-- dialog place holder -->
        <div id="dialogDiv"/>

        <script type="text/javascript" src="js/vendors/Math2.js"></script>
        <script type="text/javascript" src="js/vendors/jquery-2.2.0.min.js"></script>
        <script type="text/javascript" src="js/vendors/jquery-ui-1.11.4.base/jquery-ui.min.js"></script>
        <script type="text/javascript" src="js/vendors/jquery.blockUI.js" ></script>
        <script type="text/javascript" src="js/vendors/stats.min.js"></script>
        <script type="text/javascript" src="js/vendors/pixi.min.js"></script>
        <script type="text/javascript" src="js/vendors/papaparse.min.js"></script>

        <script type="text/javascript" src="js/psychojs/main.js"></script>
        <script type="text/javascript" src="js/psychojs/core.js"></script>
        <script type="text/javascript" src="js/psychojs/data.js"></script>
        <script type="text/javascript" src="js/psychojs/events.js"></script>
        <script type="text/javascript" src="js/psychojs/gui.js"></script>
        <script type="text/javascript" src="js/psychojs/util.js"></script>
        <script type="text/javascript" src="js/psychojs/scheduler.js"></script>
        <script type="text/javascript" src="js/psychojs/visual.js"></script>
        <script type="text/javascript" src="js/psychojs/io.js"></script>
        <script type="text/javascript" src="js/psychojs/colors.js"></script>

        <script type='text/javascript'>
            // wait until document is ready:
            $(document).ready(function() {
                with (PsychoJs) {
        
        function setupExperiment() {
            debug = false;
        
            expInfo['date'] = data.getDateStr();  // add a simple timestamp
            expInfo['expName'] = 'psreff3';
        
            filename = u'data/%s_%s_%s' % (expInfo['participant'], expName, expInfo['date']); // XXX
        
            // An ExperimentHandler isn't essential but helps with data saving
            thisExp = new data.ExperimentHandler({name:expName, version:'',
                extraInfo:expInfo, runtimeInfo:undefined,
                originPath:undefined,
                savePickle:true, saveWideText:true,
                /*dataFileName=filename*/});
        
            endExpNow = false; // flag for 'escape' or other condition => quit the exp
        
            // store frame rate of monitor if we can measure it successfully
            expInfo['frameRate']=win.getActualFrameRate();
            if (expInfo['frameRate']!=undefined) {
                frameDur = 1.0/Math.round(expInfo['frameRate']);
            }
            else {
                frameDur = 1.0/60.0; // couldn't get a reliable measure so guess
            }
        
            return NEXT;
        }
        
        function setupWin() {
            // Start Code - component code to be run before the window creation
            // Setup the Window
            win = new visual.Window({size:[1920, 1080],
                fullsc:True, screen:1.0,
                allowGUI:false, allowStencil:false,
                monitor:'testMonitor',
                color:[1, 1, 1], colorSpace:'rgb',
                blendMode:'avg',
                units:'use prefs'
                });
            return NEXT;
        }
        
        function setupResources() {
          // <<maybe need to load images for instr1?>>
          resourceManager.addResource('');
          // <<maybe need to load images for go_expl3?>>
          // <<maybe need to load images for instr2?>>
          resourceManager.addResource('');
          // <<maybe need to load images for part1?>>
          resourceManager.addResource('m_reason.csv');
          // <<maybe need to load images for mat_ev?>>
          // <<maybe need to load images for mat_ans?>>
          resourceManager.addResource('');
          // <<maybe need to load images for mat_re?>>
          // <<maybe need to load images for transition?>>
          resourceManager.addResource('initial_q.csv');
          // <<maybe need to load images for ev_iniq?>>
          resourceManager.addResource('pic_rating.csv');
          // <<maybe need to load images for ev_pic?>>
          resourceManager.addResource('');
          // <<maybe need to load images for est_sal?>>
          resourceManager.addResource('juice_types.csv');
          resourceManager.addResource('juice_salience.csv');
          resourceManager.addResource('');
          // <<maybe need to load images for jui_warn?>>
          // <<maybe need to load images for supl_jui?>>
          // <<maybe need to load images for ev_jui?>>
          // <<maybe need to load images for jui_fe?>>
          resourceManager.addResource('');
          // <<maybe need to load images for wat_warn?>>
          // <<maybe need to load images for water_disp?>>
          // <<maybe need to load images for jui_out?>>
          resourceManager.addResource('');
          // <<maybe need to load images for jui_re?>>
          // <<maybe need to load images for jui_inf?>>
          // <<maybe need to load images for transition2?>>
          resourceManager.addResource('part_1.csv');
          resourceManager.addResource('');
          resourceManager.addResource('');
          // <<maybe need to load images for rew_expl?>>
          // <<maybe need to load images for rew_ann?>>
          resourceManager.addResource('');
          resourceManager.addResource('ev.csv');
          resourceManager.addResource('');
          // <<maybe need to load images for ev_expl?>>
          // <<maybe need to load images for ev_prom?>>
          // <<maybe need to load images for ev_feed?>>
          // <<maybe need to load images for ev_save?>>
          resourceManager.addResource('');
          resourceManager.addResource('');
          resourceManager.addResource('');
          // <<maybe need to load images for eff_expl?>>
          // <<maybe need to load images for eff_expl2?>>
          // <<maybe need to load images for eff_expl3?>>
          // <<maybe need to load images for eff_expl4?>>
          // <<maybe need to load images for eff_practice?>>
          resourceManager.addResource('');
          // <<maybe need to load images for eff_midway?>>
          resourceManager.addResource('');
          // <<maybe need to load images for real_ann?>>
          // <<maybe need to load images for eff_press?>>
          // <<maybe need to load images for eff_feed?>>
          resourceManager.addResource('');
          resourceManager.addResource('');
          // <<maybe need to load images for go_expl?>>
          resourceManager.addResource('');
          // <<maybe need to load images for go_expl3?>>
          resourceManager.addResource('');
          // <<maybe need to load images for real_ann?>>
          // <<maybe need to load images for beg_fix?>>
          // <<maybe need to load images for tar_ann?>>
          // <<maybe need to load images for comp?>>
          // <<maybe need to load images for cog_eff_fin?>>
          // <<maybe need to load images for cog_eff_fin_answ?>>
          resourceManager.addResource('nasa_tlx.csv');
          // <<maybe need to load images for nasa_tlx?>>
          // <<maybe need to load images for juice_eval?>>
          resourceManager.addResource('pic_rating.csv');
          // <<maybe need to load images for ev_pic?>>
          resourceManager.addResource('nfc.csv');
          // <<maybe need to load images for nfc_scale?>>
          // <<maybe need to load images for final_screen?>>
          // then add that scheduler to the resource manager
          resourceManager.scheduleResources(resourceScheduler);
          return NEXT;
        }
        
        function experimentInit() {
          // Initialize resource loading component
          resourceManagerClock = new core.Clock();
          resourceManager = new io.ResourceManager( {win:win, target:'OSF', projectName:'stroop',  projectContributor:'Alain Pitiot', projectStatus:'PUBLIC', clock:resourceManagerClock});
          
          // Initialize components for Routine "instr1"
          instr1Clock = new core.Clock();
          text_7 = visual.TextStim(win=win, name='text_7',
              text='Welcome to the experiment! We kindly ask you to turn off your phone and put it in your bag/on the chair behind you. If your phone is turned on, it will interfere with the signal and cause data loss for us. ',
              font='Arial',
              pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-2.0);
          text_9 = visual.TextStim(win=win, name='text_9',
              text='Press SPACE to continue!',
              font='Arial',
              pos=(0, -0.6), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-3.0);
          
          // Initialize components for Routine "go_expl3"
          go_expl3Clock = new core.Clock();
          text_106 = visual.TextStim(win=win, name='text_106',
              text="Let's practice!",
              font='Arial',
              pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=0.0);
          
          // Initialize components for Routine "instr2"
          instr2Clock = new core.Clock();
          text_79 = visual.TextStim(win=win, name='text_79',
              text='default text',
              font='Arial',
              pos=(0, 0.6), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-1.0);
          text_80 = visual.TextStim(win=win, name='text_80',
              text='default text',
              font='Arial',
              pos=(0, -0.9), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-3.0);
          
          // Initialize components for Routine "part1"
          part1Clock = new core.Clock();
          text_84 = visual.TextStim(win=win, name='text_84',
              text='Part I: Tell us about yourself!',
              font='Arial',
              pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=0.0);
          text_87 = visual.TextStim(win=win, name='text_87',
              text='Press SPACE to continue!    ',
              font='Arial',
              pos=(0, -0.6), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-2.0);
          
          // Initialize components for Routine "mat_ev"
          mat_evClock = new core.Clock();
          text_55 = visual.TextStim(win=win, name='text_55',
              text='default text',
              font='Arial',
              pos=(0, 0.87), height=0.1, wrapWidth=1.4, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-3.0);
          diagnostics_3 = visual.TextStim(win=win, name='diagnostics_3',
              text='default text',
              font='Arial',
              pos=(0.4, 0.8), height=0.05, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=0,
              depth=-4.0);
          
          // Initialize components for Routine "mat_ans"
          mat_ansClock = new core.Clock();
          text_51 = visual.TextStim(win=win, name='text_51',
              text='You have chosen:',
              font='Arial',
              pos=(0, 0.6), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-2.0);
          text_52 = visual.TextStim(win=win, name='text_52',
              text='default text',
              font='Arial',
              pos=(0, 0.4), height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-3.0);
          text_53 = visual.TextStim(win=win, name='text_53',
              text='If this is true, press "y". \nIf you want to choose again, press "n".',
              font='Arial',
              pos=(0, 0.05), height=0.1, wrapWidth=0.6, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-5.0);
          diagnostics = visual.TextStim(win=win, name='diagnostics',
              text='default text',
              font='Arial',
              pos=(0.4, 0.8), height=0.05, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=0,
              depth=-7.0);
          
          // Initialize components for Routine "mat_re"
          mat_reClock = new core.Clock();
          diagnostics_2 = visual.TextStim(win=win, name='diagnostics_2',
              text='default text',
              font='Arial',
              pos=(0.4, 0.8), height=0.05, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=0,
              depth=-3.0);
          
          // Initialize components for Routine "transition"
          transitionClock = new core.Clock();
          text_54 = visual.TextStim(win=win, name='text_54',
              text='Great job! We would now like you to answer a number of questions!',
              font='Arial',
              pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-1.0);
          text_66 = visual.TextStim(win=win, name='text_66',
              text='default text',
              font='Arial',
              pos=(0, 0.8), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-2.0);
          text_67 = visual.TextStim(win=win, name='text_67',
              text='default text',
              font='Arial',
              pos=(0, -0.4), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-3.0);
          text_68 = visual.TextStim(win=win, name='text_68',
              text='default text',
              font='Arial',
              pos=(0, 0.9), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-5.0);
          text_69 = visual.TextStim(win=win, name='text_69',
              text='Press SPACE to continue!',
              font='Arial',
              pos=(0, -0.6), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-6.0);
          
          // Initialize components for Routine "ev_iniq"
          ev_iniqClock = new core.Clock();
          text_44 = visual.TextStim(win=win, name='text_44',
              text='default text',
              font='Arial',
              pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-2.0);
          
          // Initialize components for Routine "ev_pic"
          ev_picClock = new core.Clock();
          text_49 = visual.TextStim(win=win, name='text_49',
              text='How much do you like this picture?',
              font='Arial',
              pos=(0, 0.6), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-3.0);
          
          // Initialize components for Routine "est_sal"
          est_salClock = new core.Clock();
          text_24 = visual.TextStim(win=win, name='text_24',
              text='default text',
              font='Arial',
              pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-1.0);
          text_29 = visual.TextStim(win=win, name='text_29',
              text='Press SPACE to continue!',
              font='Arial',
              pos=(0, -0.6), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-3.0);
          
          // Initialize components for Routine "jui_warn"
          jui_warnClock = new core.Clock();
          text_88 = visual.TextStim(win=win, name='text_88',
              text='You will now receive juice!',
              font='Arial',
              pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=0.0);
          
          // Initialize components for Routine "supl_jui"
          supl_juiClock = new core.Clock();
          text_4 = visual.TextStim(win=win, name='text_4',
              text='default text',
              font='Arial',
              pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-1.0);
          
          // Initialize components for Routine "ev_jui"
          ev_juiClock = new core.Clock();
          text_30 = visual.TextStim(win=win, name='text_30',
              text='default text',
              font='Arial',
              pos=(0, 0.6), height=0.1, wrapWidth=0.8, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-2.0);
          text_31 = visual.TextStim(win=win, name='text_31',
              text='1',
              font='Arial',
              pos=[-0.8, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-9.0);
          text_32 = visual.TextStim(win=win, name='text_32',
              text='2',
              font='Arial',
              pos=[-0.5, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-10.0);
          text_33 = visual.TextStim(win=win, name='text_33',
              text='3',
              font='Arial',
              pos=[-0.2, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-11.0);
          text_34 = visual.TextStim(win=win, name='text_34',
              text='4',
              font='Arial',
              pos=[0.1, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-12.0);
          text_35 = visual.TextStim(win=win, name='text_35',
              text='5',
              font='Arial',
              pos=[0.4, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-13.0);
          text_22 = visual.TextStim(win=win, name='text_22',
              text='6',
              font='Arial',
              pos=[0.7, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-14.0);
          
          // Initialize components for Routine "jui_fe"
          jui_feClock = new core.Clock();
          text_36 = visual.TextStim(win=win, name='text_36',
              text='1',
              font='Arial',
              pos=[-0.8, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-7.0);
          text_37 = visual.TextStim(win=win, name='text_37',
              text='2',
              font='Arial',
              pos=[-0.5, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-8.0);
          text_38 = visual.TextStim(win=win, name='text_38',
              text='3',
              font='Arial',
              pos=[-0.2, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-9.0);
          text_39 = visual.TextStim(win=win, name='text_39',
              text='4',
              font='Arial',
              pos=[0.1, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-10.0);
          text_40 = visual.TextStim(win=win, name='text_40',
              text='5',
              font='Arial',
              pos=[0,0], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-11.0);
          text_25 = visual.TextStim(win=win, name='text_25',
              text='6',
              font='Arial',
              pos=(0.7, -0.58), height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-12.0);
          
          // Initialize components for Routine "wat_warn"
          wat_warnClock = new core.Clock();
          palate_cleanse = visual.TextStim(win=win, name='palate_cleanse',
              text='You will now receive water to wash out the juice!',
              font='Arial',
              pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=0.0);
          
          // Initialize components for Routine "water_disp"
          water_dispClock = new core.Clock();
          prompt_next = visual.TextStim(win=win, name='prompt_next',
              text='Get ready for the next one!',
              font='Arial',
              pos=(0, 0), height=0.2, wrapWidth=None, ori=0, 
              color=1.0, colorSpace='rgb', opacity=1,
              depth=-1.0);
          
          // Initialize components for Routine "jui_out"
          jui_outClock = new core.Clock();
          fav_juice_t = visual.TextStim(win=win, name='fav_juice_t',
              text='Your favourite juice was:',
              font='Arial',
              pos=(0, 0.8), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-1.0);
          conf_prompt = visual.TextStim(win=win, name='conf_prompt',
              text='Please confirm by pressing "y" if this is correct or "n" if you want to choose another one.',
              font='Arial',
              pos=(0, -0.4), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-3.0);
          
          // Initialize components for Routine "jui_re"
          jui_reClock = new core.Clock();
          mouse_prompt = visual.TextStim(win=win, name='mouse_prompt',
              text='Click on your favourite juice with the mouse:',
              font='Arial',
              pos=(0, 0.4), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-1.0);
          
          // Initialize components for Routine "jui_inf"
          jui_infClock = new core.Clock();
          
          // Initialize components for Routine "transition2"
          transition2Clock = new core.Clock();
          text_73 = visual.TextStim(win=win, name='text_73',
              text='Part II: Get ready for the games!',
              font='Arial',
              pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-1.0);
          
          // Initialize components for Routine "rew_expl"
          rew_explClock = new core.Clock();
          text_41 = visual.TextStim(win=win, name='text_41',
              text='default text',
              font='Arial',
              pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-1.0);
          text_42 = visual.TextStim(win=win, name='text_42',
              text='Press SPACE to continue!',
              font='Arial',
              pos=(0, -0.6), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-3.0);
          text_82 = visual.TextStim(win=win, name='text_82',
              text='Tutorial',
              font='Arial',
              pos=(-0.8, 0.8), height=1.0, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1.0,
              depth=-4.0);
          
          // Initialize components for Routine "rew_ann"
          rew_annClock = new core.Clock();
          text_2 = visual.TextStim(win=win, name='text_2',
              text='You are playing for:',
              font='Arial',
              pos=(0, 0.6), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-1.0);
          text_81 = visual.TextStim(win=win, name='text_81',
              text='Tutorial',
              font='Arial',
              pos=(-0.8, 0.8), height=1.0, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1.0,
              depth=-3.0);
          
          // Initialize components for Routine "ev_expl"
          ev_explClock = new core.Clock();
          text_45 = visual.TextStim(win=win, name='text_45',
              text='default text',
              font='Arial',
              pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-1.0);
          text_64 = visual.TextStim(win=win, name='text_64',
              text='Press SPACE to continue!',
              font='Arial',
              pos=(0, -0.6), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-3.0);
          text_89 = visual.TextStim(win=win, name='text_89',
              text='Tutorial',
              font='Arial',
              pos=(-0.8, 0.8), height=1.0, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-4.0);
          
          // Initialize components for Routine "ev_prom"
          ev_promClock = new core.Clock();
          text_5 = visual.TextStim(win=win, name='text_5',
              text='default text',
              font='Arial',
              pos=(0, 0.6), height=0.1, wrapWidth=0.8, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-2.0);
          text_12 = visual.TextStim(win=win, name='text_12',
              text='1',
              font='Arial',
              pos=[-0.8, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-9.0);
          text_13 = visual.TextStim(win=win, name='text_13',
              text='2',
              font='Arial',
              pos=[-0.5, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-10.0);
          text_14 = visual.TextStim(win=win, name='text_14',
              text='3',
              font='Arial',
              pos=[-0.2, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-11.0);
          text_15 = visual.TextStim(win=win, name='text_15',
              text='4',
              font='Arial',
              pos=[0.1, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-12.0);
          text_16 = visual.TextStim(win=win, name='text_16',
              text='5',
              font='Arial',
              pos=[0.4, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-13.0);
          text_47 = visual.TextStim(win=win, name='text_47',
              text='6',
              font='Arial',
              pos=[0.7, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-14.0);
          text_90 = visual.TextStim(win=win, name='text_90',
              text='Tutorial',
              font='Arial',
              pos=[0,0], height=1.0, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-16.0);
          
          // Initialize components for Routine "ev_feed"
          ev_feedClock = new core.Clock();
          text_17 = visual.TextStim(win=win, name='text_17',
              text='1',
              font='Arial',
              pos=[-0.8, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-7.0);
          text_18 = visual.TextStim(win=win, name='text_18',
              text='2',
              font='Arial',
              pos=[-0.5, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-8.0);
          text_19 = visual.TextStim(win=win, name='text_19',
              text='3',
              font='Arial',
              pos=[-0.2, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-9.0);
          text_20 = visual.TextStim(win=win, name='text_20',
              text='4',
              font='Arial',
              pos=[0.1, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-10.0);
          text_21 = visual.TextStim(win=win, name='text_21',
              text='5',
              font='Arial',
              pos=[0.4, -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-11.0);
          text_46 = visual.TextStim(win=win, name='text_46',
              text='6',
              font='Arial',
              pos=[0.7,  -0.58], height=0.3, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-12.0);
          text_91 = visual.TextStim(win=win, name='text_91',
              text='Tutorial',
              font='Arial',
              pos=(-0.8, 0.8), height=1.0, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-13.0);
          
          // Initialize components for Routine "ev_save"
          ev_saveClock = new core.Clock();
          
          // Initialize components for Routine "eff_expl"
          eff_explClock = new core.Clock();
          text_50 = visual.TextStim(win=win, name='text_50',
              text='default text',
              font='Arial',
              pos=(0, 0.2), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-1.0);
          text_65 = visual.TextStim(win=win, name='text_65',
              text='Press SPACE to continue!',
              font='Arial',
              pos=(0, -0.6), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-3.0);
          text_92 = visual.TextStim(win=win, name='text_92',
              text='Tutorial',
              font='Arial',
              pos=(-0.8, 0.8), height=1.0, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-5.0);
          
          // Initialize components for Routine "eff_expl2"
          eff_expl2Clock = new core.Clock();
          text_70 = visual.TextStim(win=win, name='text_70',
              text='The size of the reward will change:',
              font='Arial',
              pos=(0, 0.85), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-1.0);
          text_28 = visual.TextStim(win=win, name='text_28',
              text='Small:',
              font='Arial',
              pos=(-0.4, 0.45), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-5.0);
          text_62 = visual.TextStim(win=win, name='text_62',
              text='Medium:',
              font='Arial',
              pos=(-0.4, 0.05), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-6.0);
          text_63 = visual.TextStim(win=win, name='text_63',
              text='Large:',
              font='Arial',
              pos=(-0.4, -0.35), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-7.0);
          text_71 = visual.TextStim(win=win, name='text_71',
              text='Press SPACE to continue!',
              font='Arial',
              pos=(0, -0.9), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-9.0);
          text_93 = visual.TextStim(win=win, name='text_93',
              text='Tutorial',
              font='Arial',
              pos=(-0.8, 0.8), height=1.0, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-10.0);
          
          // Initialize components for Routine "eff_expl3"
          eff_expl3Clock = new core.Clock();
          text_11 = visual.TextStim(win=win, name='text_11',
              text='The color of the door will change as well. It will tell you how difficult a picture sequence will be, if it will be selected by the computer:',
              font='Arial',
              pos=(0, 0.85), height=0.06, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-1.0);
          text_72 = visual.TextStim(win=win, name='text_72',
              text='Easy:',
              font='Arial',
              pos=(-0.4, 0.45), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-5.0);
          text_74 = visual.TextStim(win=win, name='text_74',
              text='Medium:',
              font='Arial',
              pos=(-0.4, 0.0), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-6.0);
          text_75 = visual.TextStim(win=win, name='text_75',
              text='Difficult:',
              font='Arial',
              pos=(-0.4, -0.45), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-7.0);
          text_76 = visual.TextStim(win=win, name='text_76',
              text='Press SPACE to continue!',
              font='Arial',
              pos=(0.0, -0.9), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-9.0);
          text_94 = visual.TextStim(win=win, name='text_94',
              text='Tutorial',
              font='Arial',
              pos=(-0.8, 0.8), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-10.0);
          
          // Initialize components for Routine "eff_expl4"
          eff_expl4Clock = new core.Clock();
          text_77 = visual.TextStim(win=win, name='text_77',
              text='You can either click on a door with your mouse to open it:\n',
              font='Arial',
              pos=(-0.3, 0.5), height=0.05, wrapWidth=0.4, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-1.0);
          text_78 = visual.TextStim(win=win, name='text_78',
              text='Or you can follow the road and leave:',
              font='Arial',
              pos=(0.3, 0.5), height=0.05, wrapWidth=0.4, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-3.0);
          text_83 = visual.TextStim(win=win, name='text_83',
              text='Press SPACE to continue.',
              font='Arial',
              pos=(0, -0.8), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-6.0);
          text_95 = visual.TextStim(win=win, name='text_95',
              text='Tutorial',
              font='Arial',
              pos=(-0.8, 0.8), height=1.0, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-7.0);
          
          // Initialize components for Routine "eff_practice"
          eff_practiceClock = new core.Clock();
          text_104 = visual.TextStim(win=win, name='text_104',
              text="Let's practice!",
              font='Arial',
              pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=0.0);
          
          // Initialize components for Routine "eff_midway"
          eff_midwayClock = new core.Clock();
          text_99 = visual.TextStim(win=win, name='text_99',
              text='You are halfway through!\nNow you will choose for:',
              font='Arial',
              pos=(0, 0.8), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=0.0);
          text_105 = visual.TextStim(win=win, name='text_105',
              text='Press SPACE to continue.',
              font='Arial',
              pos=(0, -0.9), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-5.0);
          
          // Initialize components for Routine "real_ann"
          real_annClock = new core.Clock();
          text_26 = visual.TextStim(win=win, name='text_26',
              text='Now the main game begins!',
              font='Arial',
              pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-1.0);
          text_27 = visual.TextStim(win=win, name='text_27',
              text='Press SPACE to continue!',
              font='Arial',
              pos=(0, -0.6), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-2.0);
          
          // Initialize components for Routine "eff_press"
          eff_pressClock = new core.Clock();
          text_96 = visual.TextStim(win=win, name='text_96',
              text='Tutorial',
              font='Arial',
              pos=(-0.8, 0.8), height=1.0, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-6.0);
          text_98 = visual.TextStim(win=win, name='text_98',
              text='default text',
              font='Arial',
              pos=(0.4, 0.8), height=0.04, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-7.0);
          
          // Initialize components for Routine "eff_feed"
          eff_feedClock = new core.Clock();
          text_97 = visual.TextStim(win=win, name='text_97',
              text='Tutorial',
              font='Arial',
              pos=(-0.8, 0.8), height=1.0, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-3.0);
          
          // Initialize components for Routine "go_expl"
          go_explClock = new core.Clock();
          text_low = visual.TextStim(win=win, name='text_low',
              text='default text',
              font='Arial',
              pos=(0, -0.2), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-1.0);
          text_85 = visual.TextStim(win=win, name='text_85',
              text='Press SPACE to continue!',
              font='Arial',
              pos=(0, -0.9), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-3.0);
          text_upp = visual.TextStim(win=win, name='text_upp',
              text='default text',
              font='Arial',
              pos=(0, 0.7), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-4.0);
          text_100 = visual.TextStim(win=win, name='text_100',
              text='Tutorial',
              font='Arial',
              pos=(-0.8, 0.8), height=1.0, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-7.0);
          
          // Initialize components for Routine "go_expl3"
          go_expl3Clock = new core.Clock();
          text_106 = visual.TextStim(win=win, name='text_106',
              text="Let's practice!",
              font='Arial',
              pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=0.0);
          
          // Initialize components for Routine "real_ann"
          real_annClock = new core.Clock();
          text_26 = visual.TextStim(win=win, name='text_26',
              text='Now the main game begins!',
              font='Arial',
              pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-1.0);
          text_27 = visual.TextStim(win=win, name='text_27',
              text='Press SPACE to continue!',
              font='Arial',
              pos=(0, -0.6), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-2.0);
          
          // Initialize components for Routine "beg_fix"
          beg_fixClock = new core.Clock();
          text = visual.TextStim(win=win, name='text',
              text='This round:',
              font='Arial',
              pos=(0, 0.8), height=0.2, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-1.0);
          text_101 = visual.TextStim(win=win, name='text_101',
              text='Tutorial',
              font='Arial',
              pos=(-0.8, 0.8), height=1.0, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-3.0);
          
          // Initialize components for Routine "tar_ann"
          tar_annClock = new core.Clock();
          text_102 = visual.TextStim(win=win, name='text_102',
              text='Tutorial',
              font='Arial',
              pos=(-0.8, 0,8), height=1.0, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-2.0);
          
          // Initialize components for Routine "comp"
          compClock = new core.Clock();
          text_43 = visual.TextStim(win=win, name='text_43',
              text='You have obtained:',
              font='Arial',
              pos=(0, 0.8), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-1.0);
          text_86 = visual.TextStim(win=win, name='text_86',
              text=obtained_rew,
              font='Arial',
              pos=(0, 0.6), height=0.1, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-2.0);
          text_103 = visual.TextStim(win=win, name='text_103',
              text='Tutorial',
              font='Arial',
              pos=(-0.8, 0.8), height=1.0, wrapWidth=None, ori=0, 
              color='white', colorSpace='rgb', opacity=1,
              depth=-4.0);
          
          // Initialize components for Routine "cog_eff_fin"
          cog_eff_finClock = new core.Clock();
          
          // Initialize components for Routine "cog_eff_fin_answ"
          cog_eff_fin_answClock = new core.Clock();
          
          // Initialize components for Routine "nasa_tlx"
          nasa_tlxClock = new core.Clock();
          nasa_tlx_text = visual.TextStim(win=win, name='nasa_tlx_text',
              text='default text',
              font='Arial',
              pos=(0, 0.2), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-1.0);
          
          // Initialize components for Routine "juice_eval"
          juice_evalClock = new core.Clock();
          quest_prompt = visual.TextStim(win=win, name='quest_prompt',
              text='How much do you think 100ml of juice is worth? (please write down the number in pence, e.g. for one pound, write down 100) ',
              font='Arial',
              pos=(0, 0.2), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-1.0);
          resp_box = visual.TextStim(win=win, name='resp_box',
              text='default text',
              font='Arial',
              pos=(0, -0.3), height=0.1, wrapWidth=None, ori=0, 
              color='blue', colorSpace='rgb', opacity=1,
              depth=-3.0);
          
          // Initialize components for Routine "ev_pic"
          ev_picClock = new core.Clock();
          text_49 = visual.TextStim(win=win, name='text_49',
              text='How much do you like this picture?',
              font='Arial',
              pos=(0, 0.6), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-3.0);
          
          // Initialize components for Routine "nfc_scale"
          nfc_scaleClock = new core.Clock();
          nfc_scale_text = visual.TextStim(win=win, name='nfc_scale_text',
              text='default text',
              font='Arial',
              pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=-1.0);
          
          // Initialize components for Routine "final_screen"
          final_screenClock = new core.Clock();
          text_48 = visual.TextStim(win=win, name='text_48',
              text='That was all, you are done! Thank you for your participation :)',
              font='Arial',
              pos=(0, 0), height=0.1, wrapWidth=None, ori=0, 
              color='black', colorSpace='rgb', opacity=1,
              depth=0.0);
          
          // Create some handy timers
          globalClock = new core.Clock();  // to track the time since experiment started
          routineTimer = new core.CountdownTimer();  // to track time remaining of each (non-slip) routine
          
          return NEXT;
        }
        
        function instr1Begin() {
          // update component parameters for each repeat
          instr1_resp = event.BuilderKeyResponse();
          // keep track of which components have finished
          instr1Components = [];
          instr1Components.push(instr1_resp);
          instr1Components.push(text_7);
          instr1Components.push(text_9);
        }
        
        function instr1EachFrame() {
          //------Loop for each frame of Routine 'instr1'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = instr1Clock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *instr1_resp* updates
          if (t >= 0.0 && instr1_resp.status == NOT_STARTED) {
            // keep track of start time/frame for later
            instr1_resp.tStart = t  // (not accounting for frame time here)
            instr1_resp.frameNStart = frameN  // exact frame index
            instr1_resp.status = STARTED;
            // keyboard checking is just starting
          if (instr1_resp.status == STARTED) {
            theseKeys = event.getKeys({keyList:['space']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *text_7* updates
          if (t >= 0.0 && text_7.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_7.tStart = t  // (not accounting for frame time here)
            text_7.frameNStart = frameN  // exact frame index
            text_7.setAutoDraw(true);
          }
          
          // *text_9* updates
          if (t >= 1.0 && text_9.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_9.tStart = t  // (not accounting for frame time here)
            text_9.frameNStart = frameN  // exact frame index
            text_9.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < instr1Components.length; ++i) {
            thisComponent = instr1Components[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function instr1End() {
          //------Ending Routine 'instr1'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function go_expl3Begin() {
          routineTimer.add(1.000000)
          // update component parameters for each repeat
          // keep track of which components have finished
          go_expl3Components = [];
          go_expl3Components.push(text_106);
        }
        
        function go_expl3EachFrame() {
          //------Loop for each frame of Routine 'go_expl3'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = go_expl3Clock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_106* updates
          if (t >= 0.0 && text_106.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_106.tStart = t  // (not accounting for frame time here)
            text_106.frameNStart = frameN  // exact frame index
            text_106.setAutoDraw(true);
          }
          frameRemains = 0.0 + 1.0 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_106.status == STARTED && t >= frameRemains) {
            text_106.setAutoDraw(false);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < go_expl3Components.length; ++i) {
            thisComponent = go_expl3Components[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine && routineTimer.getTime() > 0) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function go_expl3End() {
          //------Ending Routine 'go_expl3'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function instr2Begin() {
          // update component parameters for each repeat
          text_79.setText(text_instr)
          instr_resp_2 = event.BuilderKeyResponse();
          text_80.setText('Press SPACE  to continue!')
          // keep track of which components have finished
          instr2Components = [];
          instr2Components.push(text_79);
          instr2Components.push(instr_resp_2);
          instr2Components.push(text_80);
        }
        
        function instr2EachFrame() {
          //------Loop for each frame of Routine 'instr2'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = instr2Clock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_79* updates
          if (t >= 0.0 && text_79.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_79.tStart = t  // (not accounting for frame time here)
            text_79.frameNStart = frameN  // exact frame index
            text_79.setAutoDraw(true);
          }
          
          // *instr_resp_2* updates
          if (t >= 0.0 && instr_resp_2.status == NOT_STARTED) {
            // keep track of start time/frame for later
            instr_resp_2.tStart = t  // (not accounting for frame time here)
            instr_resp_2.frameNStart = frameN  // exact frame index
            instr_resp_2.status = STARTED;
            // keyboard checking is just starting
          if (instr_resp_2.status == STARTED) {
            theseKeys = event.getKeys({keyList:['space']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *text_80* updates
          if (t >= 1 && text_80.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_80.tStart = t  // (not accounting for frame time here)
            text_80.frameNStart = frameN  // exact frame index
            text_80.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < instr2Components.length; ++i) {
            thisComponent = instr2Components[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function instr2End() {
          //------Ending Routine 'instr2'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function part1Begin() {
          // update component parameters for each repeat
          key_resp_12 = event.BuilderKeyResponse();
          // keep track of which components have finished
          part1Components = [];
          part1Components.push(text_84);
          part1Components.push(key_resp_12);
          part1Components.push(text_87);
        }
        
        function part1EachFrame() {
          //------Loop for each frame of Routine 'part1'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = part1Clock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_84* updates
          if (t >= 0.0 && text_84.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_84.tStart = t  // (not accounting for frame time here)
            text_84.frameNStart = frameN  // exact frame index
            text_84.setAutoDraw(true);
          }
          
          // *key_resp_12* updates
          if (t >= 0.0 && key_resp_12.status == NOT_STARTED) {
            // keep track of start time/frame for later
            key_resp_12.tStart = t  // (not accounting for frame time here)
            key_resp_12.frameNStart = frameN  // exact frame index
            key_resp_12.status = STARTED;
            // keyboard checking is just starting
            key_resp_12.clock.reset();  // now t=0
            event.clearEvents({eventType:'keyboard'});
          if (key_resp_12.status == STARTED) {
            theseKeys = event.getKeys({keyList:['space']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              key_resp_12.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
              key_resp_12.rt = key_resp_12.clock.getTime();
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *text_87* updates
          if (t >= 1 && text_87.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_87.tStart = t  // (not accounting for frame time here)
            text_87.frameNStart = frameN  // exact frame index
            text_87.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < part1Components.length; ++i) {
            thisComponent = part1Components[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function part1End() {
          //------Ending Routine 'part1'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // check responses
          if (key_resp_12.keys in ['', [], None]) {    // No response was made
              key_resp_12.keys=None
          }
          thisExp.addData('key_resp_12.keys',key_resp_12.keys)
          if (resp.keys != undefined) {  // we had a response
              thisExp.addData('key_resp_12.rt', key_resp_12.rt)
          }
          thisExp.nextEntry()
        }
        
        function mat_evBegin() {
          // update component parameters for each repeat
          item_resp = event.BuilderKeyResponse();
          text_55.setText(begin_blurb)
          diagnostics_3.setText(diagnostics_info)
          // keep track of which components have finished
          mat_evComponents = [];
          mat_evComponents.push(item_resp);
          mat_evComponents.push(text_55);
          mat_evComponents.push(diagnostics_3);
        }
        
        function mat_evEachFrame() {
          //------Loop for each frame of Routine 'mat_ev'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = mat_evClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *item_resp* updates
          if (t >= 0.0 && item_resp.status == NOT_STARTED) {
            // keep track of start time/frame for later
            item_resp.tStart = t  // (not accounting for frame time here)
            item_resp.frameNStart = frameN  // exact frame index
            item_resp.status = STARTED;
            // keyboard checking is just starting
            item_resp.clock.reset();  // now t=0
            event.clearEvents({eventType:'keyboard'});
          if (item_resp.status == STARTED) {
            theseKeys = event.getKeys({keyList:['1', '2', '3', '4', '5', '6']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              item_resp.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
              item_resp.rt = item_resp.clock.getTime();
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *text_55* updates
          if (t >= 0.0 && text_55.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_55.tStart = t  // (not accounting for frame time here)
            text_55.frameNStart = frameN  // exact frame index
            text_55.setAutoDraw(true);
          }
          
          // *diagnostics_3* updates
          if (t >= 0.0 && diagnostics_3.status == NOT_STARTED) {
            // keep track of start time/frame for later
            diagnostics_3.tStart = t  // (not accounting for frame time here)
            diagnostics_3.frameNStart = frameN  // exact frame index
            diagnostics_3.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < mat_evComponents.length; ++i) {
            thisComponent = mat_evComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function mat_evEnd() {
          //------Ending Routine 'mat_ev'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // check responses
          if (item_resp.keys in ['', [], None]) {    // No response was made
              item_resp.keys=None
          }
          thisExp.addData('item_resp.keys',item_resp.keys)
          if (resp.keys != undefined) {  // we had a response
              thisExp.addData('item_resp.rt', item_resp.rt)
          }
          thisExp.nextEntry()
        }
        
        function mat_ansBegin() {
          // update component parameters for each repeat
          text_52.setText(chosen_item)
          matrix_reeval = event.BuilderKeyResponse();
          diagnostics.setText(diagnostics_info)
          // keep track of which components have finished
          mat_ansComponents = [];
          mat_ansComponents.push(text_51);
          mat_ansComponents.push(text_52);
          mat_ansComponents.push(matrix_reeval);
          mat_ansComponents.push(text_53);
          mat_ansComponents.push(diagnostics);
        }
        
        function mat_ansEachFrame() {
          //------Loop for each frame of Routine 'mat_ans'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = mat_ansClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_51* updates
          if (t >= 0.0 && text_51.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_51.tStart = t  // (not accounting for frame time here)
            text_51.frameNStart = frameN  // exact frame index
            text_51.setAutoDraw(true);
          }
          
          // *text_52* updates
          if (t >= 0.0 && text_52.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_52.tStart = t  // (not accounting for frame time here)
            text_52.frameNStart = frameN  // exact frame index
            text_52.setAutoDraw(true);
          }
          
          // *matrix_reeval* updates
          if (t >= 0.0 && matrix_reeval.status == NOT_STARTED) {
            // keep track of start time/frame for later
            matrix_reeval.tStart = t  // (not accounting for frame time here)
            matrix_reeval.frameNStart = frameN  // exact frame index
            matrix_reeval.status = STARTED;
            // keyboard checking is just starting
            matrix_reeval.clock.reset();  // now t=0
            event.clearEvents({eventType:'keyboard'});
          if (matrix_reeval.status == STARTED) {
            theseKeys = event.getKeys({keyList:['y', 'n']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              matrix_reeval.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
              matrix_reeval.rt = matrix_reeval.clock.getTime();
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *text_53* updates
          if (t >= 0.0 && text_53.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_53.tStart = t  // (not accounting for frame time here)
            text_53.frameNStart = frameN  // exact frame index
            text_53.setAutoDraw(true);
          }
          
          // *diagnostics* updates
          if (t >= 0.0 && diagnostics.status == NOT_STARTED) {
            // keep track of start time/frame for later
            diagnostics.tStart = t  // (not accounting for frame time here)
            diagnostics.frameNStart = frameN  // exact frame index
            diagnostics.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < mat_ansComponents.length; ++i) {
            thisComponent = mat_ansComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function mat_ansEnd() {
          //------Ending Routine 'mat_ans'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // check responses
          if (matrix_reeval.keys in ['', [], None]) {    // No response was made
              matrix_reeval.keys=None
          }
          thisExp.addData('matrix_reeval.keys',matrix_reeval.keys)
          if (resp.keys != undefined) {  // we had a response
              thisExp.addData('matrix_reeval.rt', matrix_reeval.rt)
          }
          thisExp.nextEntry()
        }
        
        function mat_reBegin() {
          // update component parameters for each repeat
          item_resp_again = event.BuilderKeyResponse();
          diagnostics_2.setText(diagnostics_info)
          // keep track of which components have finished
          mat_reComponents = [];
          mat_reComponents.push(item_resp_again);
          mat_reComponents.push(diagnostics_2);
        }
        
        function mat_reEachFrame() {
          //------Loop for each frame of Routine 'mat_re'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = mat_reClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *item_resp_again* updates
          if (t >= 0.0 && item_resp_again.status == NOT_STARTED) {
            // keep track of start time/frame for later
            item_resp_again.tStart = t  // (not accounting for frame time here)
            item_resp_again.frameNStart = frameN  // exact frame index
            item_resp_again.status = STARTED;
            // keyboard checking is just starting
            item_resp_again.clock.reset();  // now t=0
            event.clearEvents({eventType:'keyboard'});
          if (item_resp_again.status == STARTED) {
            theseKeys = event.getKeys({keyList:['1', '2', '3', '4', '5']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              item_resp_again.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
              item_resp_again.rt = item_resp_again.clock.getTime();
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *diagnostics_2* updates
          if (t >= 0.0 && diagnostics_2.status == NOT_STARTED) {
            // keep track of start time/frame for later
            diagnostics_2.tStart = t  // (not accounting for frame time here)
            diagnostics_2.frameNStart = frameN  // exact frame index
            diagnostics_2.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < mat_reComponents.length; ++i) {
            thisComponent = mat_reComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function mat_reEnd() {
          //------Ending Routine 'mat_re'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // check responses
          if (item_resp_again.keys in ['', [], None]) {    // No response was made
              item_resp_again.keys=None
          }
          thisExp.addData('item_resp_again.keys',item_resp_again.keys)
          if (resp.keys != undefined) {  // we had a response
              thisExp.addData('item_resp_again.rt', item_resp_again.rt)
          }
          thisExp.nextEntry()
        }
        
        function transitionBegin() {
          // update component parameters for each repeat
          text_66.setText(part_t)
          text_67.setText(t)
          key_resp_7 = event.BuilderKeyResponse();
          text_68.setText(ans_sum)
          // keep track of which components have finished
          transitionComponents = [];
          transitionComponents.push(text_54);
          transitionComponents.push(text_66);
          transitionComponents.push(text_67);
          transitionComponents.push(key_resp_7);
          transitionComponents.push(text_68);
          transitionComponents.push(text_69);
        }
        
        function transitionEachFrame() {
          //------Loop for each frame of Routine 'transition'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = transitionClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_54* updates
          if (t >= 0.0 && text_54.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_54.tStart = t  // (not accounting for frame time here)
            text_54.frameNStart = frameN  // exact frame index
            text_54.setAutoDraw(true);
          }
          
          // *text_66* updates
          if (t >= 0.0 && text_66.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_66.tStart = t  // (not accounting for frame time here)
            text_66.frameNStart = frameN  // exact frame index
            text_66.setAutoDraw(true);
          }
          
          // *text_67* updates
          if (t >= 0.0 && text_67.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_67.tStart = t  // (not accounting for frame time here)
            text_67.frameNStart = frameN  // exact frame index
            text_67.setAutoDraw(true);
          }
          
          // *key_resp_7* updates
          if (t >= 0.0 && key_resp_7.status == NOT_STARTED) {
            // keep track of start time/frame for later
            key_resp_7.tStart = t  // (not accounting for frame time here)
            key_resp_7.frameNStart = frameN  // exact frame index
            key_resp_7.status = STARTED;
            // keyboard checking is just starting
            key_resp_7.clock.reset();  // now t=0
            event.clearEvents({eventType:'keyboard'});
          if (key_resp_7.status == STARTED) {
            theseKeys = event.getKeys({keyList:['y', 'n', 'left', 'right', 'space']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              key_resp_7.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
              key_resp_7.rt = key_resp_7.clock.getTime();
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *text_68* updates
          if (t >= 0.0 && text_68.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_68.tStart = t  // (not accounting for frame time here)
            text_68.frameNStart = frameN  // exact frame index
            text_68.setAutoDraw(true);
          }
          
          // *text_69* updates
          if (t >= 1 && text_69.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_69.tStart = t  // (not accounting for frame time here)
            text_69.frameNStart = frameN  // exact frame index
            text_69.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < transitionComponents.length; ++i) {
            thisComponent = transitionComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function transitionEnd() {
          //------Ending Routine 'transition'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // check responses
          if (key_resp_7.keys in ['', [], None]) {    // No response was made
              key_resp_7.keys=None
          }
          thisExp.addData('key_resp_7.keys',key_resp_7.keys)
          if (resp.keys != undefined) {  // we had a response
              thisExp.addData('key_resp_7.rt', key_resp_7.rt)
          }
          thisExp.nextEntry()
        }
        
        function ev_iniqBegin() {
          // update component parameters for each repeat
          text_44.setText(initial_q)
          // keep track of which components have finished
          ev_iniqComponents = [];
          ev_iniqComponents.push(text_44);
        }
        
        function ev_iniqEachFrame() {
          //------Loop for each frame of Routine 'ev_iniq'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = ev_iniqClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_44* updates
          if (t >= 0.0 && text_44.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_44.tStart = t  // (not accounting for frame time here)
            text_44.frameNStart = frameN  // exact frame index
            text_44.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < ev_iniqComponents.length; ++i) {
            thisComponent = ev_iniqComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function ev_iniqEnd() {
          //------Ending Routine 'ev_iniq'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function ev_picBegin() {
          // update component parameters for each repeat
          // keep track of which components have finished
          ev_picComponents = [];
          ev_picComponents.push(text_49);
        }
        
        function ev_picEachFrame() {
          //------Loop for each frame of Routine 'ev_pic'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = ev_picClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_49* updates
          if (t >= 0.0 && text_49.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_49.tStart = t  // (not accounting for frame time here)
            text_49.frameNStart = frameN  // exact frame index
            text_49.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < ev_picComponents.length; ++i) {
            thisComponent = ev_picComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function ev_picEnd() {
          //------Ending Routine 'ev_pic'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function est_salBegin() {
          // update component parameters for each repeat
          text_24.setText(text_instr)
          key_resp_5 = event.BuilderKeyResponse();
          // keep track of which components have finished
          est_salComponents = [];
          est_salComponents.push(text_24);
          est_salComponents.push(key_resp_5);
          est_salComponents.push(text_29);
        }
        
        function est_salEachFrame() {
          //------Loop for each frame of Routine 'est_sal'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = est_salClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_24* updates
          if (t >= 0.0 && text_24.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_24.tStart = t  // (not accounting for frame time here)
            text_24.frameNStart = frameN  // exact frame index
            text_24.setAutoDraw(true);
          }
          
          // *key_resp_5* updates
          if (t >= 0.0 && key_resp_5.status == NOT_STARTED) {
            // keep track of start time/frame for later
            key_resp_5.tStart = t  // (not accounting for frame time here)
            key_resp_5.frameNStart = frameN  // exact frame index
            key_resp_5.status = STARTED;
            // keyboard checking is just starting
            key_resp_5.clock.reset();  // now t=0
            event.clearEvents({eventType:'keyboard'});
          if (key_resp_5.status == STARTED) {
            theseKeys = event.getKeys({keyList:['space']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              key_resp_5.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
              key_resp_5.rt = key_resp_5.clock.getTime();
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *text_29* updates
          if (t >= 1 && text_29.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_29.tStart = t  // (not accounting for frame time here)
            text_29.frameNStart = frameN  // exact frame index
            text_29.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < est_salComponents.length; ++i) {
            thisComponent = est_salComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function est_salEnd() {
          //------Ending Routine 'est_sal'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // check responses
          if (key_resp_5.keys in ['', [], None]) {    // No response was made
              key_resp_5.keys=None
          }
          thisExp.addData('key_resp_5.keys',key_resp_5.keys)
          if (resp.keys != undefined) {  // we had a response
              thisExp.addData('key_resp_5.rt', key_resp_5.rt)
          }
          thisExp.nextEntry()
        }
        
        function jui_warnBegin() {
          routineTimer.add(2.000000)
          // update component parameters for each repeat
          // keep track of which components have finished
          jui_warnComponents = [];
          jui_warnComponents.push(text_88);
        }
        
        function jui_warnEachFrame() {
          //------Loop for each frame of Routine 'jui_warn'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = jui_warnClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_88* updates
          if (t >= 0.0 && text_88.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_88.tStart = t  // (not accounting for frame time here)
            text_88.frameNStart = frameN  // exact frame index
            text_88.setAutoDraw(true);
          }
          frameRemains = 0.0 + 2 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_88.status == STARTED && t >= frameRemains) {
            text_88.setAutoDraw(false);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < jui_warnComponents.length; ++i) {
            thisComponent = jui_warnComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine && routineTimer.getTime() > 0) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function jui_warnEnd() {
          //------Ending Routine 'jui_warn'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function supl_juiBegin() {
          routineTimer.add(2.000000)
          // update component parameters for each repeat
          text_4.setText(pump)
          // keep track of which components have finished
          supl_juiComponents = [];
          supl_juiComponents.push(text_4);
        }
        
        function supl_juiEachFrame() {
          //------Loop for each frame of Routine 'supl_jui'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = supl_juiClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_4* updates
          if (t >= 0.0 && text_4.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_4.tStart = t  // (not accounting for frame time here)
            text_4.frameNStart = frameN  // exact frame index
            text_4.setAutoDraw(true);
          }
          frameRemains = 0.0 + 2 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_4.status == STARTED && t >= frameRemains) {
            text_4.setAutoDraw(false);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < supl_juiComponents.length; ++i) {
            thisComponent = supl_juiComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine && routineTimer.getTime() > 0) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function supl_juiEnd() {
          //------Ending Routine 'supl_jui'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function ev_juiBegin() {
          // update component parameters for each repeat
          juice_resp = event.BuilderKeyResponse();
          text_30.setText(current_question)
          // keep track of which components have finished
          ev_juiComponents = [];
          ev_juiComponents.push(juice_resp);
          ev_juiComponents.push(text_30);
          ev_juiComponents.push(text_31);
          ev_juiComponents.push(text_32);
          ev_juiComponents.push(text_33);
          ev_juiComponents.push(text_34);
          ev_juiComponents.push(text_35);
          ev_juiComponents.push(text_22);
        }
        
        function ev_juiEachFrame() {
          //------Loop for each frame of Routine 'ev_jui'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = ev_juiClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *juice_resp* updates
          if (t >= 0.0 && juice_resp.status == NOT_STARTED) {
            // keep track of start time/frame for later
            juice_resp.tStart = t  // (not accounting for frame time here)
            juice_resp.frameNStart = frameN  // exact frame index
            juice_resp.status = STARTED;
            // keyboard checking is just starting
            juice_resp.clock.reset();  // now t=0
            event.clearEvents({eventType:'keyboard'});
          if (juice_resp.status == STARTED) {
            theseKeys = event.getKeys({keyList:['1', '2', '3', '4', '5', '6']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              juice_resp.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
              juice_resp.rt = juice_resp.clock.getTime();
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *text_30* updates
          if (t >= 0.0 && text_30.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_30.tStart = t  // (not accounting for frame time here)
            text_30.frameNStart = frameN  // exact frame index
            text_30.setAutoDraw(true);
          }
          
          // *text_31* updates
          if (t >= 0.0 && text_31.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_31.tStart = t  // (not accounting for frame time here)
            text_31.frameNStart = frameN  // exact frame index
            text_31.setAutoDraw(true);
          }
          
          // *text_32* updates
          if (t >= 0.0 && text_32.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_32.tStart = t  // (not accounting for frame time here)
            text_32.frameNStart = frameN  // exact frame index
            text_32.setAutoDraw(true);
          }
          
          // *text_33* updates
          if (t >= 0.0 && text_33.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_33.tStart = t  // (not accounting for frame time here)
            text_33.frameNStart = frameN  // exact frame index
            text_33.setAutoDraw(true);
          }
          
          // *text_34* updates
          if (t >= 0.0 && text_34.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_34.tStart = t  // (not accounting for frame time here)
            text_34.frameNStart = frameN  // exact frame index
            text_34.setAutoDraw(true);
          }
          
          // *text_35* updates
          if (t >= 0.0 && text_35.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_35.tStart = t  // (not accounting for frame time here)
            text_35.frameNStart = frameN  // exact frame index
            text_35.setAutoDraw(true);
          }
          
          // *text_22* updates
          if (t >= 0.0 && text_22.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_22.tStart = t  // (not accounting for frame time here)
            text_22.frameNStart = frameN  // exact frame index
            text_22.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < ev_juiComponents.length; ++i) {
            thisComponent = ev_juiComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function ev_juiEnd() {
          //------Ending Routine 'ev_jui'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // check responses
          if (juice_resp.keys in ['', [], None]) {    // No response was made
              juice_resp.keys=None
          }
          thisExp.addData('juice_resp.keys',juice_resp.keys)
          if (resp.keys != undefined) {  // we had a response
              thisExp.addData('juice_resp.rt', juice_resp.rt)
          }
          thisExp.nextEntry()
        }
        
        function jui_feBegin() {
          routineTimer.add(0.500000)
          // update component parameters for each repeat
          // keep track of which components have finished
          jui_feComponents = [];
          jui_feComponents.push(text_36);
          jui_feComponents.push(text_37);
          jui_feComponents.push(text_38);
          jui_feComponents.push(text_39);
          jui_feComponents.push(text_40);
          jui_feComponents.push(text_25);
        }
        
        function jui_feEachFrame() {
          //------Loop for each frame of Routine 'jui_fe'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = jui_feClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_36* updates
          if (t >= 0.0 && text_36.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_36.tStart = t  // (not accounting for frame time here)
            text_36.frameNStart = frameN  // exact frame index
            text_36.setAutoDraw(true);
          }
          frameRemains = 0.0 + 0.5 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_36.status == STARTED && t >= frameRemains) {
            text_36.setAutoDraw(false);
          }
          
          // *text_37* updates
          if (t >= 0.0 && text_37.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_37.tStart = t  // (not accounting for frame time here)
            text_37.frameNStart = frameN  // exact frame index
            text_37.setAutoDraw(true);
          }
          frameRemains = 0.0 + 0.5 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_37.status == STARTED && t >= frameRemains) {
            text_37.setAutoDraw(false);
          }
          
          // *text_38* updates
          if (t >= 0.0 && text_38.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_38.tStart = t  // (not accounting for frame time here)
            text_38.frameNStart = frameN  // exact frame index
            text_38.setAutoDraw(true);
          }
          frameRemains = 0.0 + 0.5 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_38.status == STARTED && t >= frameRemains) {
            text_38.setAutoDraw(false);
          }
          
          // *text_39* updates
          if (t >= 0.0 && text_39.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_39.tStart = t  // (not accounting for frame time here)
            text_39.frameNStart = frameN  // exact frame index
            text_39.setAutoDraw(true);
          }
          frameRemains = 0.0 + 0.5 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_39.status == STARTED && t >= frameRemains) {
            text_39.setAutoDraw(false);
          }
          
          // *text_40* updates
          if (t >= 0.0 && text_40.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_40.tStart = t  // (not accounting for frame time here)
            text_40.frameNStart = frameN  // exact frame index
            text_40.setAutoDraw(true);
          }
          frameRemains = 0.0 + 0.5 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_40.status == STARTED && t >= frameRemains) {
            text_40.setAutoDraw(false);
          }
          if (text_40.status == STARTED){ // only update if being drawn
            text_40.setPos([0.4, -0.58], log=False)
          }
          
          // *text_25* updates
          if (t >= 0.0 && text_25.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_25.tStart = t  // (not accounting for frame time here)
            text_25.frameNStart = frameN  // exact frame index
            text_25.setAutoDraw(true);
          }
          frameRemains = 0.0 + 0.5 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_25.status == STARTED && t >= frameRemains) {
            text_25.setAutoDraw(false);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < jui_feComponents.length; ++i) {
            thisComponent = jui_feComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine && routineTimer.getTime() > 0) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function jui_feEnd() {
          //------Ending Routine 'jui_fe'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function wat_warnBegin() {
          routineTimer.add(2.000000)
          // update component parameters for each repeat
          // keep track of which components have finished
          wat_warnComponents = [];
          wat_warnComponents.push(palate_cleanse);
        }
        
        function wat_warnEachFrame() {
          //------Loop for each frame of Routine 'wat_warn'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = wat_warnClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *palate_cleanse* updates
          if (t >= 0.0 && palate_cleanse.status == NOT_STARTED) {
            // keep track of start time/frame for later
            palate_cleanse.tStart = t  // (not accounting for frame time here)
            palate_cleanse.frameNStart = frameN  // exact frame index
            palate_cleanse.setAutoDraw(true);
          }
          frameRemains = 0.0 + 2 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (palate_cleanse.status == STARTED && t >= frameRemains) {
            palate_cleanse.setAutoDraw(false);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < wat_warnComponents.length; ++i) {
            thisComponent = wat_warnComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine && routineTimer.getTime() > 0) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function wat_warnEnd() {
          //------Ending Routine 'wat_warn'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function water_dispBegin() {
          // update component parameters for each repeat
          prompt_next.setColor(col, colorSpace='rgb')
          // keep track of which components have finished
          water_dispComponents = [];
          water_dispComponents.push(prompt_next);
        }
        
        function water_dispEachFrame() {
          //------Loop for each frame of Routine 'water_disp'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = water_dispClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *prompt_next* updates
          if (t >= t1 && prompt_next.status == NOT_STARTED) {
            // keep track of start time/frame for later
            prompt_next.tStart = t  // (not accounting for frame time here)
            prompt_next.frameNStart = frameN  // exact frame index
            prompt_next.setAutoDraw(true);
          }
          frameRemains = t2 - win.monitorFramePeriod * 0.75  # most of one frame period left
          if (prompt_next.status == STARTED && t >= frameRemains) {
            prompt_next.setAutoDraw(false);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < water_dispComponents.length; ++i) {
            thisComponent = water_dispComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function water_dispEnd() {
          //------Ending Routine 'water_disp'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function jui_outBegin() {
          // update component parameters for each repeat
          juice_conf = event.BuilderKeyResponse();
          // keep track of which components have finished
          jui_outComponents = [];
          jui_outComponents.push(fav_juice_t);
          jui_outComponents.push(juice_conf);
          jui_outComponents.push(conf_prompt);
        }
        
        function jui_outEachFrame() {
          //------Loop for each frame of Routine 'jui_out'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = jui_outClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *fav_juice_t* updates
          if (t >= 0.0 && fav_juice_t.status == NOT_STARTED) {
            // keep track of start time/frame for later
            fav_juice_t.tStart = t  // (not accounting for frame time here)
            fav_juice_t.frameNStart = frameN  // exact frame index
            fav_juice_t.setAutoDraw(true);
          }
          
          // *juice_conf* updates
          if (t >= 1 && juice_conf.status == NOT_STARTED) {
            // keep track of start time/frame for later
            juice_conf.tStart = t  // (not accounting for frame time here)
            juice_conf.frameNStart = frameN  // exact frame index
            juice_conf.status = STARTED;
            // keyboard checking is just starting
            juice_conf.clock.reset();  // now t=0
            event.clearEvents({eventType:'keyboard'});
          if (juice_conf.status == STARTED) {
            theseKeys = event.getKeys({keyList:['y', 'n']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              juice_conf.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
              juice_conf.rt = juice_conf.clock.getTime();
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *conf_prompt* updates
          if (t >= 1 && conf_prompt.status == NOT_STARTED) {
            // keep track of start time/frame for later
            conf_prompt.tStart = t  // (not accounting for frame time here)
            conf_prompt.frameNStart = frameN  // exact frame index
            conf_prompt.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < jui_outComponents.length; ++i) {
            thisComponent = jui_outComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function jui_outEnd() {
          //------Ending Routine 'jui_out'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // check responses
          if (juice_conf.keys in ['', [], None]) {    // No response was made
              juice_conf.keys=None
          }
          thisExp.addData('juice_conf.keys',juice_conf.keys)
          if (resp.keys != undefined) {  // we had a response
              thisExp.addData('juice_conf.rt', juice_conf.rt)
          }
          thisExp.nextEntry()
        }
        
        function jui_reBegin() {
          // update component parameters for each repeat
          // keep track of which components have finished
          jui_reComponents = [];
          jui_reComponents.push(mouse_prompt);
        }
        
        function jui_reEachFrame() {
          //------Loop for each frame of Routine 'jui_re'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = jui_reClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *mouse_prompt* updates
          if (t >= 0.0 && mouse_prompt.status == NOT_STARTED) {
            // keep track of start time/frame for later
            mouse_prompt.tStart = t  // (not accounting for frame time here)
            mouse_prompt.frameNStart = frameN  // exact frame index
            mouse_prompt.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < jui_reComponents.length; ++i) {
            thisComponent = jui_reComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function jui_reEnd() {
          //------Ending Routine 'jui_re'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function jui_infBegin() {
          routineTimer.add(1.000000)
          // update component parameters for each repeat
          // keep track of which components have finished
          jui_infComponents = [];
        }
        
        function jui_infEachFrame() {
          //------Loop for each frame of Routine 'jui_inf'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = jui_infClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < jui_infComponents.length; ++i) {
            thisComponent = jui_infComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine && routineTimer.getTime() > 0) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function jui_infEnd() {
          //------Ending Routine 'jui_inf'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function transition2Begin() {
          routineTimer.add(2.000000)
          // update component parameters for each repeat
          // keep track of which components have finished
          transition2Components = [];
          transition2Components.push(text_73);
        }
        
        function transition2EachFrame() {
          //------Loop for each frame of Routine 'transition2'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = transition2Clock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_73* updates
          if (t >= 0.5 && text_73.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_73.tStart = t  // (not accounting for frame time here)
            text_73.frameNStart = frameN  // exact frame index
            text_73.setAutoDraw(true);
          }
          frameRemains = 0.5 + 1.5 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_73.status == STARTED && t >= frameRemains) {
            text_73.setAutoDraw(false);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < transition2Components.length; ++i) {
            thisComponent = transition2Components[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine && routineTimer.getTime() > 0) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function transition2End() {
          //------Ending Routine 'transition2'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function rew_explBegin() {
          // update component parameters for each repeat
          text_41.setText(text_rew)
          instr_resp = event.BuilderKeyResponse();
          text_82.setOpacity(tutorial_opac)
          text_82.setHeight(lh)
          // keep track of which components have finished
          rew_explComponents = [];
          rew_explComponents.push(text_41);
          rew_explComponents.push(instr_resp);
          rew_explComponents.push(text_42);
          rew_explComponents.push(text_82);
        }
        
        function rew_explEachFrame() {
          //------Loop for each frame of Routine 'rew_expl'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = rew_explClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_41* updates
          if (t >= 0.0 && text_41.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_41.tStart = t  // (not accounting for frame time here)
            text_41.frameNStart = frameN  // exact frame index
            text_41.setAutoDraw(true);
          }
          
          // *instr_resp* updates
          if (t >= 0.0 && instr_resp.status == NOT_STARTED) {
            // keep track of start time/frame for later
            instr_resp.tStart = t  // (not accounting for frame time here)
            instr_resp.frameNStart = frameN  // exact frame index
            instr_resp.status = STARTED;
            // keyboard checking is just starting
            instr_resp.clock.reset();  // now t=0
            event.clearEvents({eventType:'keyboard'});
          if (instr_resp.status == STARTED) {
            theseKeys = event.getKeys({keyList:['space']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              instr_resp.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
              instr_resp.rt = instr_resp.clock.getTime();
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *text_42* updates
          if (t >= 2 && text_42.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_42.tStart = t  // (not accounting for frame time here)
            text_42.frameNStart = frameN  // exact frame index
            text_42.setAutoDraw(true);
          }
          
          // *text_82* updates
          if (t >= 0.0 && text_82.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_82.tStart = t  // (not accounting for frame time here)
            text_82.frameNStart = frameN  // exact frame index
            text_82.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < rew_explComponents.length; ++i) {
            thisComponent = rew_explComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function rew_explEnd() {
          //------Ending Routine 'rew_expl'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // check responses
          if (instr_resp.keys in ['', [], None]) {    // No response was made
              instr_resp.keys=None
          }
          thisExp.addData('instr_resp.keys',instr_resp.keys)
          if (resp.keys != undefined) {  // we had a response
              thisExp.addData('instr_resp.rt', instr_resp.rt)
          }
          thisExp.nextEntry()
        }
        
        function rew_annBegin() {
          routineTimer.add(5.000000)
          // update component parameters for each repeat
          text_81.setOpacity(tutorial_opac)
          text_81.setHeight(lh)
          // keep track of which components have finished
          rew_annComponents = [];
          rew_annComponents.push(text_2);
          rew_annComponents.push(text_81);
        }
        
        function rew_annEachFrame() {
          //------Loop for each frame of Routine 'rew_ann'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = rew_annClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_2* updates
          if (t >= 0.0 && text_2.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_2.tStart = t  // (not accounting for frame time here)
            text_2.frameNStart = frameN  // exact frame index
            text_2.setAutoDraw(true);
          }
          frameRemains = 0.0 + 5 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_2.status == STARTED && t >= frameRemains) {
            text_2.setAutoDraw(false);
          }
          
          // *text_81* updates
          if (t >= 0.0 && text_81.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_81.tStart = t  // (not accounting for frame time here)
            text_81.frameNStart = frameN  // exact frame index
            text_81.setAutoDraw(true);
          }
          frameRemains = 0.0 + 5 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_81.status == STARTED && t >= frameRemains) {
            text_81.setAutoDraw(false);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < rew_annComponents.length; ++i) {
            thisComponent = rew_annComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine && routineTimer.getTime() > 0) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function rew_annEnd() {
          //------Ending Routine 'rew_ann'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function ev_explBegin() {
          // update component parameters for each repeat
          text_45.setText(text_rew)
          key_resp_6 = event.BuilderKeyResponse();
          text_89.setHeight(lh)
          // keep track of which components have finished
          ev_explComponents = [];
          ev_explComponents.push(text_45);
          ev_explComponents.push(key_resp_6);
          ev_explComponents.push(text_64);
          ev_explComponents.push(text_89);
        }
        
        function ev_explEachFrame() {
          //------Loop for each frame of Routine 'ev_expl'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = ev_explClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_45* updates
          if (t >= 0.0 && text_45.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_45.tStart = t  // (not accounting for frame time here)
            text_45.frameNStart = frameN  // exact frame index
            text_45.setAutoDraw(true);
          }
          
          // *key_resp_6* updates
          if (t >= 0.0 && key_resp_6.status == NOT_STARTED) {
            // keep track of start time/frame for later
            key_resp_6.tStart = t  // (not accounting for frame time here)
            key_resp_6.frameNStart = frameN  // exact frame index
            key_resp_6.status = STARTED;
            // keyboard checking is just starting
          if (key_resp_6.status == STARTED) {
            theseKeys = event.getKeys({keyList:['space']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *text_64* updates
          if (t >= 1 && text_64.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_64.tStart = t  // (not accounting for frame time here)
            text_64.frameNStart = frameN  // exact frame index
            text_64.setAutoDraw(true);
          }
          
          // *text_89* updates
          if (t >= 0.0 && text_89.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_89.tStart = t  // (not accounting for frame time here)
            text_89.frameNStart = frameN  // exact frame index
            text_89.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < ev_explComponents.length; ++i) {
            thisComponent = ev_explComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function ev_explEnd() {
          //------Ending Routine 'ev_expl'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function ev_promBegin() {
          // update component parameters for each repeat
          ev_resp = event.BuilderKeyResponse();
          text_5.setText(current_question)
          text_90.setPos((-0.8, 0.8))
          text_90.setHeight(lh)
          // keep track of which components have finished
          ev_promComponents = [];
          ev_promComponents.push(ev_resp);
          ev_promComponents.push(text_5);
          ev_promComponents.push(text_12);
          ev_promComponents.push(text_13);
          ev_promComponents.push(text_14);
          ev_promComponents.push(text_15);
          ev_promComponents.push(text_16);
          ev_promComponents.push(text_47);
          ev_promComponents.push(text_90);
        }
        
        function ev_promEachFrame() {
          //------Loop for each frame of Routine 'ev_prom'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = ev_promClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *ev_resp* updates
          if (t >= 0.0 && ev_resp.status == NOT_STARTED) {
            // keep track of start time/frame for later
            ev_resp.tStart = t  // (not accounting for frame time here)
            ev_resp.frameNStart = frameN  // exact frame index
            ev_resp.status = STARTED;
            // keyboard checking is just starting
            ev_resp.clock.reset();  // now t=0
            event.clearEvents({eventType:'keyboard'});
          if (ev_resp.status == STARTED) {
            theseKeys = event.getKeys({keyList:['1', '2', '3', '4', '5', '6']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              ev_resp.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
              ev_resp.rt = ev_resp.clock.getTime();
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *text_5* updates
          if (t >= 0.0 && text_5.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_5.tStart = t  // (not accounting for frame time here)
            text_5.frameNStart = frameN  // exact frame index
            text_5.setAutoDraw(true);
          }
          
          // *text_12* updates
          if (t >= 0.0 && text_12.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_12.tStart = t  // (not accounting for frame time here)
            text_12.frameNStart = frameN  // exact frame index
            text_12.setAutoDraw(true);
          }
          
          // *text_13* updates
          if (t >= 0.0 && text_13.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_13.tStart = t  // (not accounting for frame time here)
            text_13.frameNStart = frameN  // exact frame index
            text_13.setAutoDraw(true);
          }
          
          // *text_14* updates
          if (t >= 0.0 && text_14.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_14.tStart = t  // (not accounting for frame time here)
            text_14.frameNStart = frameN  // exact frame index
            text_14.setAutoDraw(true);
          }
          
          // *text_15* updates
          if (t >= 0.0 && text_15.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_15.tStart = t  // (not accounting for frame time here)
            text_15.frameNStart = frameN  // exact frame index
            text_15.setAutoDraw(true);
          }
          
          // *text_16* updates
          if (t >= 0.0 && text_16.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_16.tStart = t  // (not accounting for frame time here)
            text_16.frameNStart = frameN  // exact frame index
            text_16.setAutoDraw(true);
          }
          
          // *text_47* updates
          if (t >= 0.0 && text_47.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_47.tStart = t  // (not accounting for frame time here)
            text_47.frameNStart = frameN  // exact frame index
            text_47.setAutoDraw(true);
          }
          
          // *text_90* updates
          if (t >= 0.0 && text_90.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_90.tStart = t  // (not accounting for frame time here)
            text_90.frameNStart = frameN  // exact frame index
            text_90.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < ev_promComponents.length; ++i) {
            thisComponent = ev_promComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function ev_promEnd() {
          //------Ending Routine 'ev_prom'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // check responses
          if (ev_resp.keys in ['', [], None]) {    // No response was made
              ev_resp.keys=None
          }
          thisExp.addData('ev_resp.keys',ev_resp.keys)
          if (resp.keys != undefined) {  // we had a response
              thisExp.addData('ev_resp.rt', ev_resp.rt)
          }
          thisExp.nextEntry()
        }
        
        function ev_feedBegin() {
          routineTimer.add(0.500000)
          // update component parameters for each repeat
          text_91.setHeight(lh)
          // keep track of which components have finished
          ev_feedComponents = [];
          ev_feedComponents.push(text_17);
          ev_feedComponents.push(text_18);
          ev_feedComponents.push(text_19);
          ev_feedComponents.push(text_20);
          ev_feedComponents.push(text_21);
          ev_feedComponents.push(text_46);
          ev_feedComponents.push(text_91);
        }
        
        function ev_feedEachFrame() {
          //------Loop for each frame of Routine 'ev_feed'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = ev_feedClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_17* updates
          if (t >= 0.0 && text_17.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_17.tStart = t  // (not accounting for frame time here)
            text_17.frameNStart = frameN  // exact frame index
            text_17.setAutoDraw(true);
          }
          frameRemains = 0.0 + 0.5 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_17.status == STARTED && t >= frameRemains) {
            text_17.setAutoDraw(false);
          }
          
          // *text_18* updates
          if (t >= 0.0 && text_18.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_18.tStart = t  // (not accounting for frame time here)
            text_18.frameNStart = frameN  // exact frame index
            text_18.setAutoDraw(true);
          }
          frameRemains = 0.0 + 0.5 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_18.status == STARTED && t >= frameRemains) {
            text_18.setAutoDraw(false);
          }
          
          // *text_19* updates
          if (t >= 0.0 && text_19.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_19.tStart = t  // (not accounting for frame time here)
            text_19.frameNStart = frameN  // exact frame index
            text_19.setAutoDraw(true);
          }
          frameRemains = 0.0 + 0.5 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_19.status == STARTED && t >= frameRemains) {
            text_19.setAutoDraw(false);
          }
          
          // *text_20* updates
          if (t >= 0.0 && text_20.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_20.tStart = t  // (not accounting for frame time here)
            text_20.frameNStart = frameN  // exact frame index
            text_20.setAutoDraw(true);
          }
          frameRemains = 0.0 + 0.5 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_20.status == STARTED && t >= frameRemains) {
            text_20.setAutoDraw(false);
          }
          
          // *text_21* updates
          if (t >= 0.0 && text_21.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_21.tStart = t  // (not accounting for frame time here)
            text_21.frameNStart = frameN  // exact frame index
            text_21.setAutoDraw(true);
          }
          frameRemains = 0.0 + 0.5 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_21.status == STARTED && t >= frameRemains) {
            text_21.setAutoDraw(false);
          }
          
          // *text_46* updates
          if (t >= 0.0 && text_46.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_46.tStart = t  // (not accounting for frame time here)
            text_46.frameNStart = frameN  // exact frame index
            text_46.setAutoDraw(true);
          }
          frameRemains = 0.0 + 0.5 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_46.status == STARTED && t >= frameRemains) {
            text_46.setAutoDraw(false);
          }
          
          // *text_91* updates
          if (t >= 0.0 && text_91.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_91.tStart = t  // (not accounting for frame time here)
            text_91.frameNStart = frameN  // exact frame index
            text_91.setAutoDraw(true);
          }
          frameRemains = 0.0 + 0.5 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_91.status == STARTED && t >= frameRemains) {
            text_91.setAutoDraw(false);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < ev_feedComponents.length; ++i) {
            thisComponent = ev_feedComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine && routineTimer.getTime() > 0) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function ev_feedEnd() {
          //------Ending Routine 'ev_feed'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function ev_saveBegin() {
          // update component parameters for each repeat
          // keep track of which components have finished
          ev_saveComponents = [];
        }
        
        function ev_saveEachFrame() {
          //------Loop for each frame of Routine 'ev_save'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = ev_saveClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < ev_saveComponents.length; ++i) {
            thisComponent = ev_saveComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function ev_saveEnd() {
          //------Ending Routine 'ev_save'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function eff_explBegin() {
          // update component parameters for each repeat
          text_50.setText(curr_text)
          key_resp_8 = event.BuilderKeyResponse();
          text_92.setHeight(lh)
          // keep track of which components have finished
          eff_explComponents = [];
          eff_explComponents.push(text_50);
          eff_explComponents.push(key_resp_8);
          eff_explComponents.push(text_65);
          eff_explComponents.push(text_92);
        }
        
        function eff_explEachFrame() {
          //------Loop for each frame of Routine 'eff_expl'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = eff_explClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_50* updates
          if (t >= 0.0 && text_50.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_50.tStart = t  // (not accounting for frame time here)
            text_50.frameNStart = frameN  // exact frame index
            text_50.setAutoDraw(true);
          }
          
          // *key_resp_8* updates
          if (t >= 0.0 && key_resp_8.status == NOT_STARTED) {
            // keep track of start time/frame for later
            key_resp_8.tStart = t  // (not accounting for frame time here)
            key_resp_8.frameNStart = frameN  // exact frame index
            key_resp_8.status = STARTED;
            // keyboard checking is just starting
          if (key_resp_8.status == STARTED) {
            theseKeys = event.getKeys({keyList:['space']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *text_65* updates
          if (t >= 1 && text_65.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_65.tStart = t  // (not accounting for frame time here)
            text_65.frameNStart = frameN  // exact frame index
            text_65.setAutoDraw(true);
          }
          
          // *text_92* updates
          if (t >= 0.0 && text_92.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_92.tStart = t  // (not accounting for frame time here)
            text_92.frameNStart = frameN  // exact frame index
            text_92.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < eff_explComponents.length; ++i) {
            thisComponent = eff_explComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function eff_explEnd() {
          //------Ending Routine 'eff_expl'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function eff_expl2Begin() {
          // update component parameters for each repeat
          key_resp_4 = event.BuilderKeyResponse();
          text_93.setHeight(lh)
          // keep track of which components have finished
          eff_expl2Components = [];
          eff_expl2Components.push(text_70);
          eff_expl2Components.push(text_28);
          eff_expl2Components.push(text_62);
          eff_expl2Components.push(text_63);
          eff_expl2Components.push(key_resp_4);
          eff_expl2Components.push(text_71);
          eff_expl2Components.push(text_93);
        }
        
        function eff_expl2EachFrame() {
          //------Loop for each frame of Routine 'eff_expl2'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = eff_expl2Clock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_70* updates
          if (t >= 0.0 && text_70.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_70.tStart = t  // (not accounting for frame time here)
            text_70.frameNStart = frameN  // exact frame index
            text_70.setAutoDraw(true);
          }
          
          // *text_28* updates
          if (t >= 0.0 && text_28.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_28.tStart = t  // (not accounting for frame time here)
            text_28.frameNStart = frameN  // exact frame index
            text_28.setAutoDraw(true);
          }
          
          // *text_62* updates
          if (t >= 0.0 && text_62.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_62.tStart = t  // (not accounting for frame time here)
            text_62.frameNStart = frameN  // exact frame index
            text_62.setAutoDraw(true);
          }
          
          // *text_63* updates
          if (t >= 0.0 && text_63.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_63.tStart = t  // (not accounting for frame time here)
            text_63.frameNStart = frameN  // exact frame index
            text_63.setAutoDraw(true);
          }
          
          // *key_resp_4* updates
          if (t >= 0.0 && key_resp_4.status == NOT_STARTED) {
            // keep track of start time/frame for later
            key_resp_4.tStart = t  // (not accounting for frame time here)
            key_resp_4.frameNStart = frameN  // exact frame index
            key_resp_4.status = STARTED;
            // keyboard checking is just starting
          if (key_resp_4.status == STARTED) {
            theseKeys = event.getKeys({keyList:['space']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *text_71* updates
          if (t >= 1 && text_71.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_71.tStart = t  // (not accounting for frame time here)
            text_71.frameNStart = frameN  // exact frame index
            text_71.setAutoDraw(true);
          }
          
          // *text_93* updates
          if (t >= 0.0 && text_93.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_93.tStart = t  // (not accounting for frame time here)
            text_93.frameNStart = frameN  // exact frame index
            text_93.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < eff_expl2Components.length; ++i) {
            thisComponent = eff_expl2Components[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function eff_expl2End() {
          //------Ending Routine 'eff_expl2'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function eff_expl3Begin() {
          // update component parameters for each repeat
          key_resp_9 = event.BuilderKeyResponse();
          // keep track of which components have finished
          eff_expl3Components = [];
          eff_expl3Components.push(text_11);
          eff_expl3Components.push(text_72);
          eff_expl3Components.push(text_74);
          eff_expl3Components.push(text_75);
          eff_expl3Components.push(key_resp_9);
          eff_expl3Components.push(text_76);
          eff_expl3Components.push(text_94);
        }
        
        function eff_expl3EachFrame() {
          //------Loop for each frame of Routine 'eff_expl3'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = eff_expl3Clock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_11* updates
          if (t >= 0.0 && text_11.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_11.tStart = t  // (not accounting for frame time here)
            text_11.frameNStart = frameN  // exact frame index
            text_11.setAutoDraw(true);
          }
          
          // *text_72* updates
          if (t >= 0.0 && text_72.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_72.tStart = t  // (not accounting for frame time here)
            text_72.frameNStart = frameN  // exact frame index
            text_72.setAutoDraw(true);
          }
          
          // *text_74* updates
          if (t >= 0.0 && text_74.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_74.tStart = t  // (not accounting for frame time here)
            text_74.frameNStart = frameN  // exact frame index
            text_74.setAutoDraw(true);
          }
          
          // *text_75* updates
          if (t >= 0.0 && text_75.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_75.tStart = t  // (not accounting for frame time here)
            text_75.frameNStart = frameN  // exact frame index
            text_75.setAutoDraw(true);
          }
          
          // *key_resp_9* updates
          if (t >= 0.0 && key_resp_9.status == NOT_STARTED) {
            // keep track of start time/frame for later
            key_resp_9.tStart = t  // (not accounting for frame time here)
            key_resp_9.frameNStart = frameN  // exact frame index
            key_resp_9.status = STARTED;
            // keyboard checking is just starting
            key_resp_9.clock.reset();  // now t=0
          if (key_resp_9.status == STARTED) {
            theseKeys = event.getKeys({keyList:['space']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              key_resp_9.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
              key_resp_9.rt = key_resp_9.clock.getTime();
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *text_76* updates
          if (t >= 1 && text_76.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_76.tStart = t  // (not accounting for frame time here)
            text_76.frameNStart = frameN  // exact frame index
            text_76.setAutoDraw(true);
          }
          
          // *text_94* updates
          if (t >= 0.0 && text_94.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_94.tStart = t  // (not accounting for frame time here)
            text_94.frameNStart = frameN  // exact frame index
            text_94.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < eff_expl3Components.length; ++i) {
            thisComponent = eff_expl3Components[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function eff_expl3End() {
          //------Ending Routine 'eff_expl3'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // check responses
          if (key_resp_9.keys in ['', [], None]) {    // No response was made
              key_resp_9.keys=None
          }
          thisExp.addData('key_resp_9.keys',key_resp_9.keys)
          if (resp.keys != undefined) {  // we had a response
              thisExp.addData('key_resp_9.rt', key_resp_9.rt)
          }
          thisExp.nextEntry()
        }
        
        function eff_expl4Begin() {
          // update component parameters for each repeat
          key_resp_10 = event.BuilderKeyResponse();
          text_95.setHeight(lh)
          // keep track of which components have finished
          eff_expl4Components = [];
          eff_expl4Components.push(text_77);
          eff_expl4Components.push(text_78);
          eff_expl4Components.push(key_resp_10);
          eff_expl4Components.push(text_83);
          eff_expl4Components.push(text_95);
        }
        
        function eff_expl4EachFrame() {
          //------Loop for each frame of Routine 'eff_expl4'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = eff_expl4Clock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_77* updates
          if (t >= 0.0 && text_77.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_77.tStart = t  // (not accounting for frame time here)
            text_77.frameNStart = frameN  // exact frame index
            text_77.setAutoDraw(true);
          }
          
          // *text_78* updates
          if (t >= 2 && text_78.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_78.tStart = t  // (not accounting for frame time here)
            text_78.frameNStart = frameN  // exact frame index
            text_78.setAutoDraw(true);
          }
          
          // *key_resp_10* updates
          if (t >= 0.0 && key_resp_10.status == NOT_STARTED) {
            // keep track of start time/frame for later
            key_resp_10.tStart = t  // (not accounting for frame time here)
            key_resp_10.frameNStart = frameN  // exact frame index
            key_resp_10.status = STARTED;
            // keyboard checking is just starting
          if (key_resp_10.status == STARTED) {
            theseKeys = event.getKeys({keyList:['space']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *text_83* updates
          if (t >= 1 && text_83.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_83.tStart = t  // (not accounting for frame time here)
            text_83.frameNStart = frameN  // exact frame index
            text_83.setAutoDraw(true);
          }
          
          // *text_95* updates
          if (t >= 0.0 && text_95.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_95.tStart = t  // (not accounting for frame time here)
            text_95.frameNStart = frameN  // exact frame index
            text_95.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < eff_expl4Components.length; ++i) {
            thisComponent = eff_expl4Components[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function eff_expl4End() {
          //------Ending Routine 'eff_expl4'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function eff_practiceBegin() {
          routineTimer.add(1.000000)
          // update component parameters for each repeat
          // keep track of which components have finished
          eff_practiceComponents = [];
          eff_practiceComponents.push(text_104);
        }
        
        function eff_practiceEachFrame() {
          //------Loop for each frame of Routine 'eff_practice'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = eff_practiceClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_104* updates
          if (t >= 0.0 && text_104.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_104.tStart = t  // (not accounting for frame time here)
            text_104.frameNStart = frameN  // exact frame index
            text_104.setAutoDraw(true);
          }
          frameRemains = 0.0 + 1.0 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_104.status == STARTED && t >= frameRemains) {
            text_104.setAutoDraw(false);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < eff_practiceComponents.length; ++i) {
            thisComponent = eff_practiceComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine && routineTimer.getTime() > 0) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function eff_practiceEnd() {
          //------Ending Routine 'eff_practice'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function eff_midwayBegin() {
          // update component parameters for each repeat
          key_resp_13 = event.BuilderKeyResponse();
          // keep track of which components have finished
          eff_midwayComponents = [];
          eff_midwayComponents.push(text_99);
          eff_midwayComponents.push(key_resp_13);
          eff_midwayComponents.push(text_105);
        }
        
        function eff_midwayEachFrame() {
          //------Loop for each frame of Routine 'eff_midway'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = eff_midwayClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_99* updates
          if (t >= 0.0 && text_99.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_99.tStart = t  // (not accounting for frame time here)
            text_99.frameNStart = frameN  // exact frame index
            text_99.setAutoDraw(true);
          }
          
          // *key_resp_13* updates
          if (t >= 0.0 && key_resp_13.status == NOT_STARTED) {
            // keep track of start time/frame for later
            key_resp_13.tStart = t  // (not accounting for frame time here)
            key_resp_13.frameNStart = frameN  // exact frame index
            key_resp_13.status = STARTED;
            // keyboard checking is just starting
            event.clearEvents({eventType:'keyboard'});
          if (key_resp_13.status == STARTED) {
            theseKeys = event.getKeys({keyList:['space']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *text_105* updates
          if (t >= 1 && text_105.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_105.tStart = t  // (not accounting for frame time here)
            text_105.frameNStart = frameN  // exact frame index
            text_105.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < eff_midwayComponents.length; ++i) {
            thisComponent = eff_midwayComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function eff_midwayEnd() {
          //------Ending Routine 'eff_midway'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function real_annBegin() {
          // update component parameters for each repeat
          key_resp_3 = event.BuilderKeyResponse();
          // keep track of which components have finished
          real_annComponents = [];
          real_annComponents.push(text_26);
          real_annComponents.push(text_27);
          real_annComponents.push(key_resp_3);
        }
        
        function real_annEachFrame() {
          //------Loop for each frame of Routine 'real_ann'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = real_annClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_26* updates
          if (t >= 0.0 && text_26.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_26.tStart = t  // (not accounting for frame time here)
            text_26.frameNStart = frameN  // exact frame index
            text_26.setAutoDraw(true);
          }
          
          // *text_27* updates
          if (t >= 1 && text_27.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_27.tStart = t  // (not accounting for frame time here)
            text_27.frameNStart = frameN  // exact frame index
            text_27.setAutoDraw(true);
          }
          
          // *key_resp_3* updates
          if (t >= 0.0 && key_resp_3.status == NOT_STARTED) {
            // keep track of start time/frame for later
            key_resp_3.tStart = t  // (not accounting for frame time here)
            key_resp_3.frameNStart = frameN  // exact frame index
            key_resp_3.status = STARTED;
            // keyboard checking is just starting
            key_resp_3.clock.reset();  // now t=0
            event.clearEvents({eventType:'keyboard'});
          if (key_resp_3.status == STARTED) {
            theseKeys = event.getKeys({keyList:['space']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              key_resp_3.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
              key_resp_3.rt = key_resp_3.clock.getTime();
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < real_annComponents.length; ++i) {
            thisComponent = real_annComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function real_annEnd() {
          //------Ending Routine 'real_ann'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // check responses
          if (key_resp_3.keys in ['', [], None]) {    // No response was made
              key_resp_3.keys=None
          }
          thisExp.addData('key_resp_3.keys',key_resp_3.keys)
          if (resp.keys != undefined) {  // we had a response
              thisExp.addData('key_resp_3.rt', key_resp_3.rt)
          }
          thisExp.nextEntry()
        }
        
        function eff_pressBegin() {
          // update component parameters for each repeat
          text_96.setHeight(lh)
          text_98.setText(str(tmp_design_matrix))
          // keep track of which components have finished
          eff_pressComponents = [];
          eff_pressComponents.push(text_96);
          eff_pressComponents.push(text_98);
        }
        
        function eff_pressEachFrame() {
          //------Loop for each frame of Routine 'eff_press'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = eff_pressClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_96* updates
          if (t >= 0.0 && text_96.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_96.tStart = t  // (not accounting for frame time here)
            text_96.frameNStart = frameN  // exact frame index
            text_96.setAutoDraw(true);
          }
          
          // *text_98* updates
          if (t >= 0.0 && text_98.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_98.tStart = t  // (not accounting for frame time here)
            text_98.frameNStart = frameN  // exact frame index
            text_98.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < eff_pressComponents.length; ++i) {
            thisComponent = eff_pressComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function eff_pressEnd() {
          //------Ending Routine 'eff_press'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function eff_feedBegin() {
          routineTimer.add(0.500000)
          // update component parameters for each repeat
          text_97.setHeight(lh)
          // keep track of which components have finished
          eff_feedComponents = [];
          eff_feedComponents.push(text_97);
        }
        
        function eff_feedEachFrame() {
          //------Loop for each frame of Routine 'eff_feed'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = eff_feedClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_97* updates
          if (t >= 0.0 && text_97.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_97.tStart = t  // (not accounting for frame time here)
            text_97.frameNStart = frameN  // exact frame index
            text_97.setAutoDraw(true);
          }
          frameRemains = 0.0 + 0.5 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_97.status == STARTED && t >= frameRemains) {
            text_97.setAutoDraw(false);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < eff_feedComponents.length; ++i) {
            thisComponent = eff_feedComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine && routineTimer.getTime() > 0) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function eff_feedEnd() {
          //------Ending Routine 'eff_feed'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function go_explBegin() {
          // update component parameters for each repeat
          text_low.setText(curr_low)
          key_resp_11 = event.BuilderKeyResponse();
          text_upp.setText(curr_upp)
          text_100.setHeight(lh)
          // keep track of which components have finished
          go_explComponents = [];
          go_explComponents.push(text_low);
          go_explComponents.push(key_resp_11);
          go_explComponents.push(text_85);
          go_explComponents.push(text_upp);
          go_explComponents.push(text_100);
        }
        
        function go_explEachFrame() {
          //------Loop for each frame of Routine 'go_expl'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = go_explClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_low* updates
          if (t >= 0.0 && text_low.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_low.tStart = t  // (not accounting for frame time here)
            text_low.frameNStart = frameN  // exact frame index
            text_low.setAutoDraw(true);
          }
          
          // *key_resp_11* updates
          if (t >= 0.0 && key_resp_11.status == NOT_STARTED) {
            // keep track of start time/frame for later
            key_resp_11.tStart = t  // (not accounting for frame time here)
            key_resp_11.frameNStart = frameN  // exact frame index
            key_resp_11.status = STARTED;
            // keyboard checking is just starting
            event.clearEvents({eventType:'keyboard'});
          if (key_resp_11.status == STARTED) {
            theseKeys = event.getKeys({keyList:['space']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *text_85* updates
          if (t >= 1 && text_85.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_85.tStart = t  // (not accounting for frame time here)
            text_85.frameNStart = frameN  // exact frame index
            text_85.setAutoDraw(true);
          }
          
          // *text_upp* updates
          if (t >= 0.0 && text_upp.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_upp.tStart = t  // (not accounting for frame time here)
            text_upp.frameNStart = frameN  // exact frame index
            text_upp.setAutoDraw(true);
          }
          
          // *text_100* updates
          if (t >= 0.0 && text_100.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_100.tStart = t  // (not accounting for frame time here)
            text_100.frameNStart = frameN  // exact frame index
            text_100.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < go_explComponents.length; ++i) {
            thisComponent = go_explComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function go_explEnd() {
          //------Ending Routine 'go_expl'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function go_expl3Begin() {
          routineTimer.add(1.000000)
          // update component parameters for each repeat
          // keep track of which components have finished
          go_expl3Components = [];
          go_expl3Components.push(text_106);
        }
        
        function go_expl3EachFrame() {
          //------Loop for each frame of Routine 'go_expl3'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = go_expl3Clock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_106* updates
          if (t >= 0.0 && text_106.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_106.tStart = t  // (not accounting for frame time here)
            text_106.frameNStart = frameN  // exact frame index
            text_106.setAutoDraw(true);
          }
          frameRemains = 0.0 + 1.0 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_106.status == STARTED && t >= frameRemains) {
            text_106.setAutoDraw(false);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < go_expl3Components.length; ++i) {
            thisComponent = go_expl3Components[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine && routineTimer.getTime() > 0) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function go_expl3End() {
          //------Ending Routine 'go_expl3'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function real_annBegin() {
          // update component parameters for each repeat
          key_resp_3 = event.BuilderKeyResponse();
          // keep track of which components have finished
          real_annComponents = [];
          real_annComponents.push(text_26);
          real_annComponents.push(text_27);
          real_annComponents.push(key_resp_3);
        }
        
        function real_annEachFrame() {
          //------Loop for each frame of Routine 'real_ann'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = real_annClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_26* updates
          if (t >= 0.0 && text_26.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_26.tStart = t  // (not accounting for frame time here)
            text_26.frameNStart = frameN  // exact frame index
            text_26.setAutoDraw(true);
          }
          
          // *text_27* updates
          if (t >= 1 && text_27.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_27.tStart = t  // (not accounting for frame time here)
            text_27.frameNStart = frameN  // exact frame index
            text_27.setAutoDraw(true);
          }
          
          // *key_resp_3* updates
          if (t >= 0.0 && key_resp_3.status == NOT_STARTED) {
            // keep track of start time/frame for later
            key_resp_3.tStart = t  // (not accounting for frame time here)
            key_resp_3.frameNStart = frameN  // exact frame index
            key_resp_3.status = STARTED;
            // keyboard checking is just starting
            key_resp_3.clock.reset();  // now t=0
            event.clearEvents({eventType:'keyboard'});
          if (key_resp_3.status == STARTED) {
            theseKeys = event.getKeys({keyList:['space']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              key_resp_3.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
              key_resp_3.rt = key_resp_3.clock.getTime();
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < real_annComponents.length; ++i) {
            thisComponent = real_annComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function real_annEnd() {
          //------Ending Routine 'real_ann'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // check responses
          if (key_resp_3.keys in ['', [], None]) {    // No response was made
              key_resp_3.keys=None
          }
          thisExp.addData('key_resp_3.keys',key_resp_3.keys)
          if (resp.keys != undefined) {  // we had a response
              thisExp.addData('key_resp_3.rt', key_resp_3.rt)
          }
          thisExp.nextEntry()
        }
        
        function beg_fixBegin() {
          // update component parameters for each repeat
          text_101.setHeight(lh)
          // keep track of which components have finished
          beg_fixComponents = [];
          beg_fixComponents.push(text);
          beg_fixComponents.push(text_101);
        }
        
        function beg_fixEachFrame() {
          //------Loop for each frame of Routine 'beg_fix'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = beg_fixClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text* updates
          if (t >= 0.0 && text.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text.tStart = t  // (not accounting for frame time here)
            text.frameNStart = frameN  // exact frame index
            text.setAutoDraw(true);
          }
          frameRemains = 0.0 + curr_t - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text.status == STARTED && t >= frameRemains) {
            text.setAutoDraw(false);
          }
          
          // *text_101* updates
          if (t >= 0.0 && text_101.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_101.tStart = t  // (not accounting for frame time here)
            text_101.frameNStart = frameN  // exact frame index
            text_101.setAutoDraw(true);
          }
          frameRemains = 0.0 + 1.0 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_101.status == STARTED && t >= frameRemains) {
            text_101.setAutoDraw(false);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < beg_fixComponents.length; ++i) {
            thisComponent = beg_fixComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function beg_fixEnd() {
          //------Ending Routine 'beg_fix'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function tar_annBegin() {
          // update component parameters for each repeat
          main_resp = event.BuilderKeyResponse();
          text_102.setHeight(lh)
          // keep track of which components have finished
          tar_annComponents = [];
          tar_annComponents.push(main_resp);
          tar_annComponents.push(text_102);
        }
        
        function tar_annEachFrame() {
          //------Loop for each frame of Routine 'tar_ann'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = tar_annClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *main_resp* updates
          if (t >= 0 && main_resp.status == NOT_STARTED) {
            // keep track of start time/frame for later
            main_resp.tStart = t  // (not accounting for frame time here)
            main_resp.frameNStart = frameN  // exact frame index
            main_resp.status = STARTED;
            // keyboard checking is just starting
            main_resp.clock.reset();  // now t=0
            event.clearEvents({eventType:'keyboard'});
          frameRemains = 0 + resp_wind - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (main_resp.status == STARTED && t >= frameRemains) {
            main_resp.status = STOPPED;
          if (main_resp.status == STARTED) {
            theseKeys = event.getKeys({keyList:['f', 'k']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              main_resp.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
              main_resp.rt = main_resp.clock.getTime();
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *text_102* updates
          if (t >= 0.0 && text_102.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_102.tStart = t  // (not accounting for frame time here)
            text_102.frameNStart = frameN  // exact frame index
            text_102.setAutoDraw(true);
          }
          frameRemains = 0.0 + resp_wind - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_102.status == STARTED && t >= frameRemains) {
            text_102.setAutoDraw(false);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < tar_annComponents.length; ++i) {
            thisComponent = tar_annComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function tar_annEnd() {
          //------Ending Routine 'tar_ann'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // check responses
          if (main_resp.keys in ['', [], None]) {    // No response was made
              main_resp.keys=None
          }
          thisExp.addData('main_resp.keys',main_resp.keys)
          if (resp.keys != undefined) {  // we had a response
              thisExp.addData('main_resp.rt', main_resp.rt)
          }
          thisExp.nextEntry()
        }
        
        function compBegin() {
          routineTimer.add(2.000000)
          // update component parameters for each repeat
          text_103.setHeight(lh)
          // keep track of which components have finished
          compComponents = [];
          compComponents.push(text_43);
          compComponents.push(text_86);
          compComponents.push(text_103);
        }
        
        function compEachFrame() {
          //------Loop for each frame of Routine 'comp'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = compClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_43* updates
          if (t >= 0.0 && text_43.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_43.tStart = t  // (not accounting for frame time here)
            text_43.frameNStart = frameN  // exact frame index
            text_43.setAutoDraw(true);
          }
          frameRemains = 0.0 + 2 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_43.status == STARTED && t >= frameRemains) {
            text_43.setAutoDraw(false);
          }
          
          // *text_86* updates
          if (t >= 0.0 && text_86.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_86.tStart = t  // (not accounting for frame time here)
            text_86.frameNStart = frameN  // exact frame index
            text_86.setAutoDraw(true);
          }
          frameRemains = 0.0 + 2 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_86.status == STARTED && t >= frameRemains) {
            text_86.setAutoDraw(false);
          }
          
          // *text_103* updates
          if (t >= 0.0 && text_103.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_103.tStart = t  // (not accounting for frame time here)
            text_103.frameNStart = frameN  // exact frame index
            text_103.setAutoDraw(true);
          }
          frameRemains = 0.0 + 2 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_103.status == STARTED && t >= frameRemains) {
            text_103.setAutoDraw(false);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < compComponents.length; ++i) {
            thisComponent = compComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine && routineTimer.getTime() > 0) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function compEnd() {
          //------Ending Routine 'comp'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function cog_eff_finBegin() {
          routineTimer.add(1.000000)
          // update component parameters for each repeat
          // keep track of which components have finished
          cog_eff_finComponents = [];
        }
        
        function cog_eff_finEachFrame() {
          //------Loop for each frame of Routine 'cog_eff_fin'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = cog_eff_finClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < cog_eff_finComponents.length; ++i) {
            thisComponent = cog_eff_finComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine && routineTimer.getTime() > 0) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function cog_eff_finEnd() {
          //------Ending Routine 'cog_eff_fin'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function cog_eff_fin_answBegin() {
          // update component parameters for each repeat
          // keep track of which components have finished
          cog_eff_fin_answComponents = [];
        }
        
        function cog_eff_fin_answEachFrame() {
          //------Loop for each frame of Routine 'cog_eff_fin_answ'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = cog_eff_fin_answClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < cog_eff_fin_answComponents.length; ++i) {
            thisComponent = cog_eff_fin_answComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function cog_eff_fin_answEnd() {
          //------Ending Routine 'cog_eff_fin_answ'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function nasa_tlxBegin() {
          // update component parameters for each repeat
          nasa_tlx_text.setText(nasa_question)
          // keep track of which components have finished
          nasa_tlxComponents = [];
          nasa_tlxComponents.push(nasa_tlx_text);
        }
        
        function nasa_tlxEachFrame() {
          //------Loop for each frame of Routine 'nasa_tlx'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = nasa_tlxClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *nasa_tlx_text* updates
          if (t >= 0.0 && nasa_tlx_text.status == NOT_STARTED) {
            // keep track of start time/frame for later
            nasa_tlx_text.tStart = t  // (not accounting for frame time here)
            nasa_tlx_text.frameNStart = frameN  // exact frame index
            nasa_tlx_text.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < nasa_tlxComponents.length; ++i) {
            thisComponent = nasa_tlxComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function nasa_tlxEnd() {
          //------Ending Routine 'nasa_tlx'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function juice_evalBegin() {
          // update component parameters for each repeat
          continue_key = event.BuilderKeyResponse();
          juice_valuation = event.BuilderKeyResponse();
          // keep track of which components have finished
          juice_evalComponents = [];
          juice_evalComponents.push(quest_prompt);
          juice_evalComponents.push(continue_key);
          juice_evalComponents.push(resp_box);
          juice_evalComponents.push(juice_valuation);
        }
        
        function juice_evalEachFrame() {
          //------Loop for each frame of Routine 'juice_eval'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = juice_evalClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *quest_prompt* updates
          if (t >= 0.0 && quest_prompt.status == NOT_STARTED) {
            // keep track of start time/frame for later
            quest_prompt.tStart = t  // (not accounting for frame time here)
            quest_prompt.frameNStart = frameN  // exact frame index
            quest_prompt.setAutoDraw(true);
          }
          
          // *continue_key* updates
          if (t >= 0.0 && continue_key.status == NOT_STARTED) {
            // keep track of start time/frame for later
            continue_key.tStart = t  // (not accounting for frame time here)
            continue_key.frameNStart = frameN  // exact frame index
            continue_key.status = STARTED;
            // keyboard checking is just starting
            continue_key.clock.reset();  // now t=0
            event.clearEvents({eventType:'keyboard'});
          if (continue_key.status == STARTED) {
            theseKeys = event.getKeys({keyList:['return']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              continue_key.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
              continue_key.rt = continue_key.clock.getTime();
              // a response ends the routine
              continueRoutine = False;
            }
          }
          
          // *resp_box* updates
          if (t >= 0.0 && resp_box.status == NOT_STARTED) {
            // keep track of start time/frame for later
            resp_box.tStart = t  // (not accounting for frame time here)
            resp_box.frameNStart = frameN  // exact frame index
            resp_box.setAutoDraw(true);
          }
          if (resp_box.status == STARTED){ // only update if being drawn
            resp_box.setText((inputText), log=False)
          }
          
          // *juice_valuation* updates
          if (t >= 0.0 && juice_valuation.status == NOT_STARTED) {
            // keep track of start time/frame for later
            juice_valuation.tStart = t  // (not accounting for frame time here)
            juice_valuation.frameNStart = frameN  // exact frame index
            juice_valuation.status = STARTED;
            // keyboard checking is just starting
            juice_valuation.clock.reset();  // now t=0
            event.clearEvents({eventType:'keyboard'});
          if (juice_valuation.status == STARTED) {
            theseKeys = event.getKeys();
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              juice_valuation.keys = concat(juice_valuation.keys, theseKeys);  // storing all keys
              juice_valuation.rt = concat(juice_valuation.rt, juice_valuation.clock.getTime());
            }
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < juice_evalComponents.length; ++i) {
            thisComponent = juice_evalComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function juice_evalEnd() {
          //------Ending Routine 'juice_eval'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // check responses
          if (continue_key.keys in ['', [], None]) {    // No response was made
              continue_key.keys=None
          }
          thisExp.addData('continue_key.keys',continue_key.keys)
          if (resp.keys != undefined) {  // we had a response
              thisExp.addData('continue_key.rt', continue_key.rt)
          }
          thisExp.nextEntry()
          // check responses
          if (juice_valuation.keys in ['', [], None]) {    // No response was made
              juice_valuation.keys=None
          }
          thisExp.addData('juice_valuation.keys',juice_valuation.keys)
          if (resp.keys != undefined) {  // we had a response
              thisExp.addData('juice_valuation.rt', juice_valuation.rt)
          }
          thisExp.nextEntry()
        }
        
        function ev_picBegin() {
          // update component parameters for each repeat
          // keep track of which components have finished
          ev_picComponents = [];
          ev_picComponents.push(text_49);
        }
        
        function ev_picEachFrame() {
          //------Loop for each frame of Routine 'ev_pic'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = ev_picClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_49* updates
          if (t >= 0.0 && text_49.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_49.tStart = t  // (not accounting for frame time here)
            text_49.frameNStart = frameN  // exact frame index
            text_49.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < ev_picComponents.length; ++i) {
            thisComponent = ev_picComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function ev_picEnd() {
          //------Ending Routine 'ev_pic'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function nfc_scaleBegin() {
          // update component parameters for each repeat
          nfc_scale_text.setText(nfc_question
)
          // keep track of which components have finished
          nfc_scaleComponents = [];
          nfc_scaleComponents.push(nfc_scale_text);
        }
        
        function nfc_scaleEachFrame() {
          //------Loop for each frame of Routine 'nfc_scale'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = nfc_scaleClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *nfc_scale_text* updates
          if (t >= 0.0 && nfc_scale_text.status == NOT_STARTED) {
            // keep track of start time/frame for later
            nfc_scale_text.tStart = t  // (not accounting for frame time here)
            nfc_scale_text.frameNStart = frameN  // exact frame index
            nfc_scale_text.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < nfc_scaleComponents.length; ++i) {
            thisComponent = nfc_scaleComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function nfc_scaleEnd() {
          //------Ending Routine 'nfc_scale'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function final_screenBegin() {
          routineTimer.add(1.000000)
          // update component parameters for each repeat
          // keep track of which components have finished
          final_screenComponents = [];
          final_screenComponents.push(text_48);
        }
        
        function final_screenEachFrame() {
          //------Loop for each frame of Routine 'final_screen'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = final_screenClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text_48* updates
          if (t >= 0.0 && text_48.status == NOT_STARTED) {
            // keep track of start time/frame for later
            text_48.tStart = t  // (not accounting for frame time here)
            text_48.frameNStart = frameN  // exact frame index
            text_48.setAutoDraw(true);
          }
          frameRemains = 0.0 + 1.0 - win.monitorFramePeriod * 0.75  // most of one frame period left
          if (text_48.status == STARTED && t >= frameRemains) {
            text_48.setAutoDraw(false);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < final_screenComponents.length; ++i) {
            thisComponent = final_screenComponents[i];
            if ('status' in thisComponent && thisComponent.status != FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || event.getKeys({keyList:['escape']}).length > 0) {
            core.quit();
          }
          
          // refresh the screen if continuing
          if (continueRoutine && routineTimer.getTime() > 0) {
            return FLIP_REPEAT;
          }
          else {
            return NEXT;
          }
        }
        
        function final_screenEnd() {
          //------Ending Routine 'final_screen'-------
          for (var i = 0; i < instructComponents.length; ++i) {
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
        }
        
        function quitPsychoJS() {
            win.close()
            core.quit();
            return QUIT;
        }

        run();
        }
      });
    </script>

  </body>
</html>